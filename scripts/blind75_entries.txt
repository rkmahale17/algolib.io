  "two-sum": {
    "id": "two-sum",
    "name": "Two Sum",
    "title": "Two Sum",
    "category": "Array",
    "explanation": {
        "problemStatement": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\nConstraints:\n• 2 <= nums.length <= 10^4\n• -10^9 <= nums[i] <= 10^9\n• -10^9 <= target <= 10^9\n• Only one valid answer exists.",
        "io": [],
        "constraints": [],
        "note": "Use a hash map to store each number and its index as we iterate. For each number, check if its complement (target - current number) exists in the hash map. If found, return both indices. Otherwise, add the current number to the hash map.",
        "steps": [],
        "useCase": "Finding pairs in datasets, Complement search in databases, Financial transaction matching",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Google",
        "Facebook",
        "Microsoft"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function twoSum(nums: number[], target: number): number[] {\n    // Hash map to store number and its index\n    const seen = new Map<number, number>();\n    \n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        \n        // Check if complement exists in hash map\n        if (seen.has(complement)) {\n            return [seen.get(complement)!, i];\n        }\n        \n        // Store current number and its index\n        seen.set(nums[i], i);\n    }\n    \n    return []; // No solution found\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def twoSum(nums: List[int], target: int) -> List[int]:\n    # Hash map to store number and its index\n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        # Check if complement exists in hash map\n        if complement in seen:\n            return [seen[complement], i]\n        \n        # Store current number and its index\n        seen[num] = i\n    \n    return []  # No solution found"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int[] twoSum(int[] nums, int target) {\n    // Hash map to store number and its index\n    Map<Integer, Integer> seen = new HashMap<>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        \n        // Check if complement exists in hash map\n        if (seen.containsKey(complement)) {\n            return new int[] { seen.get(complement), i };\n        }\n        \n        // Store current number and its index\n        seen.put(nums[i], i);\n    }\n    \n    return new int[] {}; // No solution found\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "vector<int> twoSum(vector<int>& nums, int target) {\n    // Hash map to store number and its index\n    unordered_map<int, int> seen;\n    \n    for (int i = 0; i < nums.size(); i++) {\n        int complement = target - nums[i];\n        \n        // Check if complement exists in hash map\n        if (seen.find(complement) != seen.end()) {\n            return {seen[complement], i};\n        }\n        \n        // Store current number and its index\n        seen[nums[i]] = i;\n    }\n    \n    return {}; // No solution found\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use a hash map to store each number and its index as we iterate. For each number, check if its complement (target - current number) exists in the hash map. If found, return both indices. Otherwise, add the current number to the hash map.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=KLlXCFG5TnA",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/two-sum/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "best-time-to-buy-and-sell-stock": {
    "id": "best-time-to-buy-and-sell-stock",
    "name": "Best Time to Buy and Sell Stock",
    "title": "Best Time to Buy and Sell Stock",
    "category": "Array",
    "explanation": {
        "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n\nExample 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: No transactions are done and the max profit = 0.\n\nConstraints:\n• 1 <= prices.length <= 10^5\n• 0 <= prices[i] <= 10^4",
        "io": [],
        "constraints": [],
        "note": "Track the minimum price seen so far and the maximum profit. For each price, calculate the profit if we sell at that price (current price - minimum price). Update the maximum profit if this profit is greater.",
        "steps": [],
        "useCase": "Stock trading algorithms, Price optimization, Timing market entries",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft",
        "Facebook"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function maxProfit(prices: number[]): number {\n    if (prices.length === 0) return 0;\n    \n    let minPrice = Infinity;\n    let maxProfit = 0;\n    \n    for (const price of prices) {\n        // Update minimum price seen so far\n        minPrice = Math.min(minPrice, price);\n        \n        // Calculate profit if we sell at current price\n        const profit = price - minPrice;\n        \n        // Update maximum profit\n        maxProfit = Math.max(maxProfit, profit);\n    }\n    \n    return maxProfit;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def maxProfit(prices: List[int]) -> int:\n    if not prices:\n        return 0\n    \n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:\n        # Update minimum price seen so far\n        min_price = min(min_price, price)\n        \n        # Calculate profit if we sell at current price\n        profit = price - min_price\n        \n        # Update maximum profit\n        max_profit = max(max_profit, profit)\n    \n    return max_profit"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int maxProfit(int[] prices) {\n    if (prices.length == 0) return 0;\n    \n    int minPrice = Integer.MAX_VALUE;\n    int maxProfit = 0;\n    \n    for (int price : prices) {\n        // Update minimum price seen so far\n        minPrice = Math.min(minPrice, price);\n        \n        // Calculate profit if we sell at current price\n        int profit = price - minPrice;\n        \n        // Update maximum profit\n        maxProfit = Math.max(maxProfit, profit);\n    }\n    \n    return maxProfit;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int maxProfit(vector<int>& prices) {\n    if (prices.empty()) return 0;\n    \n    int minPrice = INT_MAX;\n    int maxProfit = 0;\n    \n    for (int price : prices) {\n        // Update minimum price seen so far\n        minPrice = min(minPrice, price);\n        \n        // Calculate profit if we sell at current price\n        int profit = price - minPrice;\n        \n        // Update maximum profit\n        maxProfit = max(maxProfit, profit);\n    }\n    \n    return maxProfit;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Track the minimum price seen so far and the maximum profit. For each price, calculate the profit if we sell at that price (current price - minimum price). Update the maximum profit if this profit is greater.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=1pkOgXD63yU",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "contains-duplicate": {
    "id": "contains-duplicate",
    "name": "Contains Duplicate",
    "title": "Contains Duplicate",
    "category": "Array",
    "explanation": {
        "problemStatement": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\n\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: true\n\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: false\n\nExample 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n\nConstraints:\n• 1 <= nums.length <= 10^5\n• -10^9 <= nums[i] <= 10^9",
        "io": [],
        "constraints": [],
        "note": "Use a hash set to track numbers we've seen. As we iterate through the array, if we encounter a number that's already in the set, we have a duplicate. Otherwise, add the number to the set and continue.",
        "steps": [],
        "useCase": "Duplicate detection in databases, Data validation, Unique constraint checking",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Apple",
        "Adobe"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function containsDuplicate(nums: number[]): boolean {\n    // Use a Set to track seen numbers\n    const seen = new Set<number>();\n    \n    for (const num of nums) {\n        if (seen.has(num)) {\n            return true;\n        }\n        seen.add(num);\n    }\n    \n    return false;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def containsDuplicate(nums: List[int]) -> bool:\n    # Use a set to track seen numbers\n    seen = set()\n    \n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    \n    return False\n\n# Alternative one-liner\n# return len(nums) != len(set(nums))"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean containsDuplicate(int[] nums) {\n    // Use a HashSet to track seen numbers\n    Set<Integer> seen = new HashSet<>();\n    \n    for (int num : nums) {\n        if (seen.contains(num)) {\n            return true;\n        }\n        seen.add(num);\n    }\n    \n    return false;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool containsDuplicate(vector<int>& nums) {\n    // Use an unordered_set to track seen numbers\n    unordered_set<int> seen;\n    \n    for (int num : nums) {\n        if (seen.find(num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    \n    return false;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use a hash set to track numbers we've seen. As we iterate through the array, if we encounter a number that's already in the set, we have a duplicate. Otherwise, add the number to the set and continue.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=3OamzN90kPg",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/contains-duplicate/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "product-of-array-except-self": {
    "id": "product-of-array-except-self",
    "name": "Product of Array Except Self",
    "title": "Product of Array Except Self",
    "category": "Array",
    "explanation": {
        "problemStatement": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.\n\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\n\nExample 2:\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n\nConstraints:\n• 2 <= nums.length <= 10^5\n• -30 <= nums[i] <= 30\n• The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nFollow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space.)",
        "io": [],
        "constraints": [],
        "note": "Two-pass approach: First pass calculates product of all elements to the left of each index. Second pass calculates product of all elements to the right and multiplies with left products. This avoids division and achieves O(1) space (excluding output array).",
        "steps": [],
        "useCase": "Statistical calculations, Array transformations, Mathematical computations",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Microsoft"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function productExceptSelf(nums: number[]): number[] {\n    const n = nums.length;\n    const result = new Array(n).fill(1);\n    \n    // Calculate left products\n    let leftProduct = 1;\n    for (let i = 0; i < n; i++) {\n        result[i] = leftProduct;\n        leftProduct *= nums[i];\n    }\n    \n    // Calculate right products and multiply with left\n    let rightProduct = 1;\n    for (let i = n - 1; i >= 0; i--) {\n        result[i] *= rightProduct;\n        rightProduct *= nums[i];\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def productExceptSelf(nums: List[int]) -> List[int]:\n    n = len(nums)\n    result = [1] * n\n    \n    # Calculate left products\n    left_product = 1\n    for i in range(n):\n        result[i] = left_product\n        left_product *= nums[i]\n    \n    # Calculate right products and multiply with left\n    right_product = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= right_product\n        right_product *= nums[i]\n    \n    return result"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int[] productExceptSelf(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n    Arrays.fill(result, 1);\n    \n    // Calculate left products\n    int leftProduct = 1;\n    for (int i = 0; i < n; i++) {\n        result[i] = leftProduct;\n        leftProduct *= nums[i];\n    }\n    \n    // Calculate right products and multiply with left\n    int rightProduct = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        result[i] *= rightProduct;\n        rightProduct *= nums[i];\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "vector<int> productExceptSelf(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> result(n, 1);\n    \n    // Calculate left products\n    int leftProduct = 1;\n    for (int i = 0; i < n; i++) {\n        result[i] = leftProduct;\n        leftProduct *= nums[i];\n    }\n    \n    // Calculate right products and multiply with left\n    int rightProduct = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        result[i] *= rightProduct;\n        rightProduct *= nums[i];\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Two-pass approach: First pass calculates product of all elements to the left of each index. Second pass calculates product of all elements to the right and multiplies with left products. This avoids division and achieves O(1) space (excluding output array).",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=bNvIQI2wAjk",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/product-of-array-except-self/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "maximum-subarray": {
    "id": "maximum-subarray",
    "name": "Maximum Subarray",
    "title": "Maximum Subarray",
    "category": "Array",
    "explanation": {
        "problemStatement": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\nExample 1:\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nExample 2:\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n\nExample 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n\nConstraints:\n• 1 <= nums.length <= 10^5\n• -10^4 <= nums[i] <= 10^4\n\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach.",
        "io": [],
        "constraints": [],
        "note": "Kadane's Algorithm: Maintain current sum of subarray. At each element, decide whether to extend the existing subarray or start a new one from the current element. Track the maximum sum seen so far.",
        "steps": [],
        "useCase": "Financial analysis, Maximum profit calculation, Pattern recognition in data",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft",
        "LinkedIn"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function maxSubArray(nums: number[]): number {\n    // Kadane's Algorithm\n    let maxSum = nums[0];\n    let currentSum = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        // Either extend the existing subarray or start new\n        currentSum = Math.max(nums[i], currentSum + nums[i]);\n        \n        // Update maximum sum found\n        maxSum = Math.max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def maxSubArray(nums: List[int]) -> int:\n    # Kadane's Algorithm\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        # Either extend the existing subarray or start new\n        current_sum = max(nums[i], current_sum + nums[i])\n        \n        # Update maximum sum found\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int maxSubArray(int[] nums) {\n    // Kadane's Algorithm\n    int maxSum = nums[0];\n    int currentSum = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n        // Either extend the existing subarray or start new\n        currentSum = Math.max(nums[i], currentSum + nums[i]);\n        \n        // Update maximum sum found\n        maxSum = Math.max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int maxSubArray(vector<int>& nums) {\n    // Kadane's Algorithm\n    int maxSum = nums[0];\n    int currentSum = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        // Either extend the existing subarray or start new\n        currentSum = max(nums[i], currentSum + nums[i]);\n        \n        // Update maximum sum found\n        maxSum = max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Kadane's Algorithm: Maintain current sum of subarray. At each element, decide whether to extend the existing subarray or start a new one from the current element. Track the maximum sum seen so far.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=5WZl3MMT0Eg",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/maximum-subarray/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "maximum-product-subarray": {
    "id": "maximum-product-subarray",
    "name": "Maximum Product Subarray",
    "title": "Maximum Product Subarray",
    "category": "Array",
    "explanation": {
        "problemStatement": "Given an integer array nums, find a subarray that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.\n\nExample 1:\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.\n\nExample 2:\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.\n\nConstraints:\n• 1 <= nums.length <= 2 * 10^4\n• -10 <= nums[i] <= 10\n• The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",
        "io": [],
        "constraints": [],
        "note": "Track both maximum and minimum products at each position. A negative number can turn the minimum into maximum and vice versa. At each step, consider: the current number alone, current number × current max, or current number × current min.",
        "steps": [],
        "useCase": "Optimization problems, Product calculations, Dynamic programming applications",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "LinkedIn"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function maxProduct(nums: number[]): number {\n    if (nums.length === 0) return 0;\n    \n    let maxProduct = nums[0];\n    let currentMax = nums[0];\n    let currentMin = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        const num = nums[i];\n        \n        // Store currentMax before updating\n        const tempMax = currentMax;\n        \n        // Update max and min\n        currentMax = Math.max(num, num * currentMax, num * currentMin);\n        currentMin = Math.min(num, num * tempMax, num * currentMin);\n        \n        // Update global maximum\n        maxProduct = Math.max(maxProduct, currentMax);\n    }\n    \n    return maxProduct;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def maxProduct(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    max_product = nums[0]\n    current_max = nums[0]\n    current_min = nums[0]\n    \n    for i in range(1, len(nums)):\n        num = nums[i]\n        \n        # Store current_max before updating\n        temp_max = current_max\n        \n        # Update max and min\n        current_max = max(num, num * current_max, num * current_min)\n        current_min = min(num, num * temp_max, num * current_min)\n        \n        # Update global maximum\n        max_product = max(max_product, current_max)\n    \n    return max_product"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int maxProduct(int[] nums) {\n    if (nums.length == 0) return 0;\n    \n    int maxProduct = nums[0];\n    int currentMax = nums[0];\n    int currentMin = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n        int num = nums[i];\n        \n        // Store currentMax before updating\n        int tempMax = currentMax;\n        \n        // Update max and min\n        currentMax = Math.max(num, Math.max(num * currentMax, num * currentMin));\n        currentMin = Math.min(num, Math.min(num * tempMax, num * currentMin));\n        \n        // Update global maximum\n        maxProduct = Math.max(maxProduct, currentMax);\n    }\n    \n    return maxProduct;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int maxProduct(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    \n    int maxProduct = nums[0];\n    int currentMax = nums[0];\n    int currentMin = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        int num = nums[i];\n        \n        // Store currentMax before updating\n        int tempMax = currentMax;\n        \n        // Update max and min\n        currentMax = max({num, num * currentMax, num * currentMin});\n        currentMin = min({num, num * tempMax, num * currentMin});\n        \n        // Update global maximum\n        maxProduct = max(maxProduct, currentMax);\n    }\n    \n    return maxProduct;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Track both maximum and minimum products at each position. A negative number can turn the minimum into maximum and vice versa. At each step, consider: the current number alone, current number × current max, or current number × current min.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=lXVy6YWFcRM",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/maximum-product-subarray/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "find-minimum-in-rotated-sorted-array": {
    "id": "find-minimum-in-rotated-sorted-array",
    "name": "Find Minimum in Rotated Sorted Array",
    "title": "Find Minimum in Rotated Sorted Array",
    "category": "Array",
    "explanation": {
        "problemStatement": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\n• [4,5,6,7,0,1,2] if it was rotated 4 times.\n• [0,1,2,4,5,6,7] if it was rotated 7 times.\n\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.\n\nExample 1:\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n\nExample 2:\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n\nExample 3:\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times.\n\nConstraints:\n• n == nums.length\n• 1 <= n <= 5000\n• -5000 <= nums[i] <= 5000\n• All the integers of nums are unique.\n• nums is sorted and rotated between 1 and n times.",
        "io": [],
        "constraints": [],
        "note": "Binary search approach. Compare mid element with right element. If mid > right, rotation point (and minimum) is in right half. Otherwise, minimum is in left half. Converge until left equals right.",
        "steps": [],
        "useCase": "Rotated array operations, Circular buffer search, Optimized search algorithms",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function findMin(nums: number[]): number {\n    let left = 0, right = nums.length - 1;\n    \n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        \n        // If mid element is greater than right element,\n        // minimum must be in right half\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            // Minimum is in left half (including mid)\n            right = mid;\n        }\n    }\n    \n    return nums[left];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def findMin(nums: List[int]) -> int:\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # If mid element is greater than right element,\n        # minimum must be in right half\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            # Minimum is in left half (including mid)\n            right = mid\n    \n    return nums[left]"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int findMin(int[] nums) {\n    int left = 0, right = nums.length - 1;\n    \n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        \n        // If mid element is greater than right element,\n        // minimum must be in right half\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            // Minimum is in left half (including mid)\n            right = mid;\n        }\n    }\n    \n    return nums[left];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int findMin(vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n    \n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        \n        // If mid element is greater than right element,\n        // minimum must be in right half\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            // Minimum is in left half (including mid)\n            right = mid;\n        }\n    }\n    \n    return nums[left];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Binary search approach. Compare mid element with right element. If mid > right, rotation point (and minimum) is in right half. Otherwise, minimum is in left half. Converge until left equals right.",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=nIVW4P8b1VA",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "search-in-rotated-sorted-array": {
    "id": "search-in-rotated-sorted-array",
    "name": "Search in Rotated Sorted Array",
    "title": "Search in Rotated Sorted Array",
    "category": "Array",
    "explanation": {
        "problemStatement": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\n\nExample 3:\nInput: nums = [1], target = 0\nOutput: -1\n\nConstraints:\n• 1 <= nums.length <= 5000\n• -10^4 <= nums[i] <= 10^4\n• All values of nums are unique.\n• nums is an ascending array that is possibly rotated.\n• -10^4 <= target <= 10^4",
        "io": [],
        "constraints": [],
        "note": "Modified binary search. At each step, determine which half is properly sorted by comparing endpoints. If target is in the sorted half's range, search that half. Otherwise, search the other half. This maintains O(log n) time.",
        "steps": [],
        "useCase": "Circular buffer search, Rotated data structures, Database indexing",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Microsoft",
        "Amazon"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function search(nums: number[], target: number): number {\n    let left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        \n        if (nums[mid] === target) {\n            return mid;\n        }\n        \n        // Determine which half is sorted\n        if (nums[left] <= nums[mid]) {\n            // Left half is sorted\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            // Right half is sorted\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    \n    return -1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def search(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        # Determine which half is sorted\n        if nums[left] <= nums[mid]:\n            # Left half is sorted\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            # Right half is sorted\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        if (nums[mid] == target) {\n            return mid;\n        }\n        \n        // Determine which half is sorted\n        if (nums[left] <= nums[mid]) {\n            // Left half is sorted\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            // Right half is sorted\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    \n    return -1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        if (nums[mid] == target) {\n            return mid;\n        }\n        \n        // Determine which half is sorted\n        if (nums[left] <= nums[mid]) {\n            // Left half is sorted\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            // Right half is sorted\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    \n    return -1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Modified binary search. At each step, determine which half is properly sorted by comparing endpoints. If target is in the sorted half's range, search that half. Otherwise, search the other half. This maintains O(log n) time.",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=U8XENwh8Oy8",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "3sum": {
    "id": "3sum",
    "name": "3Sum",
    "title": "3Sum",
    "category": "Array",
    "explanation": {
        "problemStatement": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\n\nExample 2:\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\nExample 3:\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\n\nConstraints:\n• 3 <= nums.length <= 3000\n• -10^5 <= nums[i] <= 10^5",
        "io": [],
        "constraints": [],
        "note": "Sort array first. For each number, use two pointers to find pairs that sum to its negative. Skip duplicates to avoid duplicate triplets. Time: O(n²), Space: O(1) excluding output.",
        "steps": [],
        "useCase": "Finding triplets in datasets, Combinatorial searches, Financial reconciliation",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Microsoft"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function threeSum(nums: number[]): number[][] {\n    nums.sort((a, b) => a - b);\n    const result: number[][] = [];\n    \n    for (let i = 0; i < nums.length - 2; i++) {\n        // Skip duplicates for first number\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            continue;\n        }\n        \n        let left = i + 1, right = nums.length - 1;\n        const target = -nums[i];\n        \n        while (left < right) {\n            const currentSum = nums[left] + nums[right];\n            \n            if (currentSum === target) {\n                result.push([nums[i], nums[left], nums[right]]);\n                \n                // Skip duplicates for second and third numbers\n                while (left < right && nums[left] === nums[left + 1]) left++;\n                while (left < right && nums[right] === nums[right - 1]) right--;\n                \n                left++;\n                right--;\n            } else if (currentSum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def threeSum(nums: List[int]) -> List[List[int]]:\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 2):\n        # Skip duplicates for first number\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        left, right = i + 1, len(nums) - 1\n        target = -nums[i]\n        \n        while left < right:\n            current_sum = nums[left] + nums[right]\n            \n            if current_sum == target:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                # Skip duplicates for second and third numbers\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return result"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public List<List<Integer>> threeSum(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> result = new ArrayList<>();\n    \n    for (int i = 0; i < nums.length - 2; i++) {\n        // Skip duplicates for first number\n        if (i > 0 && nums[i] == nums[i - 1]) {\n            continue;\n        }\n        \n        int left = i + 1, right = nums.length - 1;\n        int target = -nums[i];\n        \n        while (left < right) {\n            int currentSum = nums[left] + nums[right];\n            \n            if (currentSum == target) {\n                result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                \n                // Skip duplicates for second and third numbers\n                while (left < right && nums[left] == nums[left + 1]) left++;\n                while (left < right && nums[right] == nums[right - 1]) right--;\n                \n                left++;\n                right--;\n            } else if (currentSum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "vector<vector<int>> threeSum(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    vector<vector<int>> result;\n    \n    for (int i = 0; i < nums.size() - 2; i++) {\n        // Skip duplicates for first number\n        if (i > 0 && nums[i] == nums[i - 1]) {\n            continue;\n        }\n        \n        int left = i + 1, right = nums.size() - 1;\n        int target = -nums[i];\n        \n        while (left < right) {\n            int currentSum = nums[left] + nums[right];\n            \n            if (currentSum == target) {\n                result.push_back({nums[i], nums[left], nums[right]});\n                \n                // Skip duplicates for second and third numbers\n                while (left < right && nums[left] == nums[left + 1]) left++;\n                while (left < right && nums[right] == nums[right - 1]) right--;\n                \n                left++;\n                right--;\n            } else if (currentSum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Sort array first. For each number, use two pointers to find pairs that sum to its negative. Skip duplicates to avoid duplicate triplets. Time: O(n²), Space: O(1) excluding output.",
    "timeComplexity": "O(n²)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=jzZsG8n2R9A",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/3sum/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "container-with-most-water": {
    "id": "container-with-most-water",
    "name": "Container With Most Water",
    "title": "Container With Most Water",
    "category": "Array",
    "explanation": {
        "problemStatement": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\nNotice that you may not slant the container.\n\nExample 1:\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. The max area of water is 49.\n\nExample 2:\nInput: height = [1,1]\nOutput: 1\n\nConstraints:\n• n == height.length\n• 2 <= n <= 10^5\n• 0 <= height[i] <= 10^4",
        "io": [],
        "constraints": [],
        "note": "Two pointers from both ends. Area is determined by min(height[left], height[right]) × width. Always move the pointer with smaller height inward, as moving the taller one can only decrease area. This greedy approach finds the maximum in O(n) time.",
        "steps": [],
        "useCase": "Area optimization, Resource allocation, Capacity planning",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Google",
        "Facebook"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function maxArea(height: number[]): number {\n    let left = 0, right = height.length - 1;\n    let maxArea = 0;\n    \n    while (left < right) {\n        // Calculate current area\n        const width = right - left;\n        const currentHeight = Math.min(height[left], height[right]);\n        const currentArea = width * currentHeight;\n        \n        // Update maximum area\n        maxArea = Math.max(maxArea, currentArea);\n        \n        // Move pointer with smaller height\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return maxArea;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def maxArea(height: List[int]) -> int:\n    left, right = 0, len(height) - 1\n    max_area = 0\n    \n    while left < right:\n        # Calculate current area\n        width = right - left\n        current_height = min(height[left], height[right])\n        current_area = width * current_height\n        \n        # Update maximum area\n        max_area = max(max_area, current_area)\n        \n        # Move pointer with smaller height\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_area"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int maxArea(int[] height) {\n    int left = 0, right = height.length - 1;\n    int maxArea = 0;\n    \n    while (left < right) {\n        // Calculate current area\n        int width = right - left;\n        int currentHeight = Math.min(height[left], height[right]);\n        int currentArea = width * currentHeight;\n        \n        // Update maximum area\n        maxArea = Math.max(maxArea, currentArea);\n        \n        // Move pointer with smaller height\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return maxArea;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int maxArea(vector<int>& height) {\n    int left = 0, right = height.size() - 1;\n    int maxArea = 0;\n    \n    while (left < right) {\n        // Calculate current area\n        int width = right - left;\n        int currentHeight = min(height[left], height[right]);\n        int currentArea = width * currentHeight;\n        \n        // Update maximum area\n        maxArea = max(maxArea, currentArea);\n        \n        // Move pointer with smaller height\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return maxArea;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Two pointers from both ends. Area is determined by min(height[left], height[right]) × width. Always move the pointer with smaller height inward, as moving the taller one can only decrease area. This greedy approach finds the maximum in O(n) time.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=UuiTKBwPgAo",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/container-with-most-water/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "sum-of-two-integers": {
    "id": "sum-of-two-integers",
    "name": "Sum of Two Integers",
    "title": "Sum of Two Integers",
    "category": "Binary",
    "explanation": {
        "problemStatement": "Given two integers a and b, return the sum of the two integers without using the operators + and -.\n\nExample 1:\nInput: a = 1, b = 2\nOutput: 3\n\nExample 2:\nInput: a = 2, b = 3\nOutput: 5\n\nNotes: Use bitwise operations (XOR and AND with shifts) to simulate addition without using + or -.",
        "io": [],
        "constraints": [],
        "note": "Use XOR to add bits without carry. Use AND + left shift to calculate carry. Repeat until no carry remains. XOR gives us the sum without considering carry, AND finds where both bits are 1 (needing carry), shift moves carry to next position.",
        "steps": [],
        "useCase": "Low-level arithmetic, Embedded systems, Bit manipulation practice",
        "tips": []
    },
    "companyTags": [
        "Amazon"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function getSum(a: number, b: number): number {\n    while (b !== 0) {\n        // Calculate carry\n        const carry = a & b;\n        \n        // Calculate sum without carry (XOR)\n        a = a ^ b;\n        \n        // Shift carry left by 1\n        b = carry << 1;\n    }\n    \n    return a;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def getSum(a: int, b: int) -> int:\n    # Use XOR for addition without carry\n    # Use AND + shift for carry\n    \n    # Python needs special handling for 32-bit integers\n    mask = 0xFFFFFFFF\n    \n    while b != 0:\n        # Calculate sum without carry (XOR)\n        # Calculate carry (AND + left shift)\n        a, b = (a ^ b) & mask, ((a & b) << 1) & mask\n    \n    # Handle negative numbers in Python\n    return a if a <= 0x7FFFFFFF else ~(a ^ mask)"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int getSum(int a, int b) {\n    while (b != 0) {\n        // Calculate carry\n        int carry = a & b;\n        \n        // Calculate sum without carry (XOR)\n        a = a ^ b;\n        \n        // Shift carry left by 1\n        b = carry << 1;\n    }\n    \n    return a;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int getSum(int a, int b) {\n    while (b != 0) {\n        // Calculate carry\n        int carry = a & b;\n        \n        // Calculate sum without carry (XOR)\n        a = a ^ b;\n        \n        // Shift carry left by 1\n        b = carry << 1;\n    }\n    \n    return a;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use XOR to add bits without carry. Use AND + left shift to calculate carry. Repeat until no carry remains. XOR gives us the sum without considering carry, AND finds where both bits are 1 (needing carry), shift moves carry to next position.",
    "timeComplexity": "O(1)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=gVUrDV4tZfY",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/sum-of-two-integers/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "number-of-1-bits": {
    "id": "number-of-1-bits",
    "name": "Number of 1 Bits",
    "title": "Number of 1 Bits",
    "category": "Binary",
    "explanation": {
        "problemStatement": "Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).\n\nExample 1:\nInput: n = 00000000000000000000000000001011\nOutput: 3\nExplanation: The binary representation has three '1' bits.\n\nExample 2:\nInput: n = 00000000000000000000000010000000\nOutput: 1\n\nConstraints: The input is a 32-bit unsigned integer.",
        "io": [],
        "constraints": [],
        "note": "Method 1: Check each bit with & 1, right shift, repeat. Method 2 (Brian Kernighan's): n & (n-1) removes rightmost 1 bit. Count how many times we can do this until n becomes 0. This is faster when there are fewer 1 bits.",
        "steps": [],
        "useCase": "Hamming weight calculation, Error detection, Binary analysis",
        "tips": []
    },
    "companyTags": [
        "Apple",
        "Microsoft"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function hammingWeight(n: number): number {\n    let count = 0;\n    \n    while (n !== 0) {\n        // Check if least significant bit is 1\n        count += n & 1;\n        // Right shift by 1\n        n >>>= 1;\n    }\n    \n    return count;\n}\n\n// Optimized version using Brian Kernighan's algorithm\nfunction hammingWeight_optimized(n: number): number {\n    let count = 0;\n    \n    while (n !== 0) {\n        // Remove rightmost 1 bit\n        n &= (n - 1);\n        count++;\n    }\n    \n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def hammingWeight(n: int) -> int:\n    count = 0\n    \n    while n:\n        # Check if least significant bit is 1\n        count += n & 1\n        # Right shift by 1\n        n >>= 1\n    \n    return count\n\n# Optimized version using Brian Kernighan's algorithm\ndef hammingWeight_optimized(n: int) -> int:\n    count = 0\n    \n    while n:\n        # Remove rightmost 1 bit\n        n &= (n - 1)\n        count += 1\n    \n    return count"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int hammingWeight(int n) {\n    int count = 0;\n    \n    while (n != 0) {\n        // Check if least significant bit is 1\n        count += n & 1;\n        // Unsigned right shift\n        n >>>= 1;\n    }\n    \n    return count;\n}\n\n// Optimized version using Brian Kernighan's algorithm\npublic int hammingWeight_optimized(int n) {\n    int count = 0;\n    \n    while (n != 0) {\n        // Remove rightmost 1 bit\n        n &= (n - 1);\n        count++;\n    }\n    \n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int hammingWeight(uint32_t n) {\n    int count = 0;\n    \n    while (n) {\n        // Check if least significant bit is 1\n        count += n & 1;\n        // Right shift by 1\n        n >>= 1;\n    }\n    \n    return count;\n}\n\n// Optimized version using Brian Kernighan's algorithm\nint hammingWeight_optimized(uint32_t n) {\n    int count = 0;\n    \n    while (n) {\n        // Remove rightmost 1 bit\n        n &= (n - 1);\n        count++;\n    }\n    \n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Method 1: Check each bit with & 1, right shift, repeat. Method 2 (Brian Kernighan's): n & (n-1) removes rightmost 1 bit. Count how many times we can do this until n becomes 0. This is faster when there are fewer 1 bits.",
    "timeComplexity": "O(1)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=gVUrDV4tZfY",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/number-of-1-bits/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "counting-bits": {
    "id": "counting-bits",
    "name": "Counting Bits",
    "title": "Counting Bits",
    "category": "Binary",
    "explanation": {
        "problemStatement": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\n\nExample 1:\nInput: n = 2\nOutput: [0,1,1]\n\nExample 2:\nInput: n = 5\nOutput: [0,1,1,2,1,2]\n\nFollow-up: Can you do it in O(n) time? Use DP relationships between numbers to compute counts efficiently.",
        "io": [],
        "constraints": [],
        "note": "Dynamic programming with bit manipulation. Key insight: number of 1 bits in i equals the number of 1 bits in i/2 (i>>1) plus 1 if i is odd (i&1). We're essentially looking at the previous number with last bit removed, then adding back that last bit if it's 1.",
        "steps": [],
        "useCase": "Dynamic programming, Bit counting, Pattern recognition",
        "tips": []
    },
    "companyTags": [
        "Amazon"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function countBits(n: number): number[] {\n    const result = new Array(n + 1).fill(0);\n    \n    for (let i = 1; i <= n; i++) {\n        // Number of 1s in i = number of 1s in (i >> 1) + (i & 1)\n        result[i] = result[i >> 1] + (i & 1);\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def countBits(n: int) -> List[int]:\n    result = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        # Number of 1s in i = number of 1s in (i >> 1) + (i & 1)\n        # i >> 1 is i divided by 2 (removing last bit)\n        # i & 1 is 1 if last bit is 1, else 0\n        result[i] = result[i >> 1] + (i & 1)\n    \n    return result"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int[] countBits(int n) {\n    int[] result = new int[n + 1];\n    \n    for (int i = 1; i <= n; i++) {\n        // Number of 1s in i = number of 1s in (i >> 1) + (i & 1)\n        result[i] = result[i >> 1] + (i & 1);\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "vector<int> countBits(int n) {\n    vector<int> result(n + 1, 0);\n    \n    for (int i = 1; i <= n; i++) {\n        // Number of 1s in i = number of 1s in (i >> 1) + (i & 1)\n        result[i] = result[i >> 1] + (i & 1);\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Dynamic programming with bit manipulation. Key insight: number of 1 bits in i equals the number of 1 bits in i/2 (i>>1) plus 1 if i is odd (i&1). We're essentially looking at the previous number with last bit removed, then adding back that last bit if it's 1.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=RyBM56RIWrM",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/counting-bits/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "missing-number": {
    "id": "missing-number",
    "name": "Missing Number",
    "title": "Missing Number",
    "category": "Binary",
    "explanation": {
        "problemStatement": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\n\nExample 1:\nInput: nums = [3,0,1]\nOutput: 2\n\nExample 2:\nInput: nums = [0,1]\nOutput: 2\n\nConstraints: You can solve it in O(n) time and O(1) additional space using XOR or arithmetic sum formula.",
        "io": [],
        "constraints": [],
        "note": "Method 1 (XOR): XOR all indices with all values. Since a ^ a = 0, all present numbers cancel out, leaving only the missing number. Method 2 (Sum): Expected sum is n(n+1)/2, subtract actual sum. Both are O(n) time, O(1) space.",
        "steps": [],
        "useCase": "Data validation, Sequence verification, XOR properties",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function missingNumber(nums: number[]): number {\n    // Method 1: XOR approach\n    let result = nums.length;\n    \n    for (let i = 0; i < nums.length; i++) {\n        result ^= i ^ nums[i];\n    }\n    \n    return result;\n}\n\n// Method 2: Sum formula\nfunction missingNumber_sum(nums: number[]): number {\n    const n = nums.length;\n    const expectedSum = n * (n + 1) / 2;\n    const actualSum = nums.reduce((sum, num) => sum + num, 0);\n    return expectedSum - actualSum;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def missingNumber(nums: List[int]) -> int:\n    # Method 1: XOR approach\n    result = len(nums)\n    \n    for i in range(len(nums)):\n        result ^= i ^ nums[i]\n    \n    return result\n\n# Method 2: Sum formula\ndef missingNumber_sum(nums: List[int]) -> int:\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int missingNumber(int[] nums) {\n    // Method 1: XOR approach\n    int result = nums.length;\n    \n    for (int i = 0; i < nums.length; i++) {\n        result ^= i ^ nums[i];\n    }\n    \n    return result;\n}\n\n// Method 2: Sum formula\npublic int missingNumber_sum(int[] nums) {\n    int n = nums.length;\n    int expectedSum = n * (n + 1) / 2;\n    int actualSum = 0;\n    \n    for (int num : nums) {\n        actualSum += num;\n    }\n    \n    return expectedSum - actualSum;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int missingNumber(vector<int>& nums) {\n    // Method 1: XOR approach\n    int result = nums.size();\n    \n    for (int i = 0; i < nums.size(); i++) {\n        result ^= i ^ nums[i];\n    }\n    \n    return result;\n}\n\n// Method 2: Sum formula\nint missingNumber_sum(vector<int>& nums) {\n    int n = nums.size();\n    int expectedSum = n * (n + 1) / 2;\n    int actualSum = 0;\n    \n    for (int num : nums) {\n        actualSum += num;\n    }\n    \n    return expectedSum - actualSum;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Method 1 (XOR): XOR all indices with all values. Since a ^ a = 0, all present numbers cancel out, leaving only the missing number. Method 2 (Sum): Expected sum is n(n+1)/2, subtract actual sum. Both are O(n) time, O(1) space.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=WnPLSRLSANE",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/missing-number/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "reverse-bits": {
    "id": "reverse-bits",
    "name": "Reverse Bits",
    "title": "Reverse Bits",
    "category": "Binary",
    "explanation": {
        "problemStatement": "Reverse bits of a given 32 bits unsigned integer and return the resulting unsigned integer.\n\nExample 1:\nInput: n = 00000010100101000001111010011100\nOutput: 00111001011110000010100101000000 (which is 964176192 in decimal)\n\nExample 2:\nInput: n = 11111111111111111111111111111101\nOutput: 10111111111111111111111111111111\n\nNote: Consider bit-by-bit reversal; for multiple calls, use caching / lookup table to optimize.",
        "io": [],
        "constraints": [],
        "note": "Process each of 32 bits from right to left. Extract rightmost bit of n with & 1, shift result left and OR the bit onto it, shift n right. This effectively builds the reversed number bit by bit from left to right while consuming n from right to left.",
        "steps": [],
        "useCase": "Bit reversal, Network protocols, Low-level operations",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Apple"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function reverseBits(n: number): number {\n    let result = 0;\n    \n    for (let i = 0; i < 32; i++) {\n        // Extract the last bit of n\n        const bit = n & 1;\n        \n        // Shift result left and add the bit\n        result = (result << 1) | bit;\n        \n        // Shift n right to process next bit\n        n >>>= 1;\n    }\n    \n    return result >>> 0; // Ensure unsigned 32-bit integer\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def reverseBits(n: int) -> int:\n    result = 0\n    \n    for i in range(32):\n        # Extract the last bit of n\n        bit = n & 1\n        \n        # Shift result left and add the bit\n        result = (result << 1) | bit\n        \n        # Shift n right to process next bit\n        n >>= 1\n    \n    return result"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int reverseBits(int n) {\n    int result = 0;\n    \n    for (int i = 0; i < 32; i++) {\n        // Extract the last bit of n\n        int bit = n & 1;\n        \n        // Shift result left and add the bit\n        result = (result << 1) | bit;\n        \n        // Shift n right to process next bit\n        n >>>= 1;\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "uint32_t reverseBits(uint32_t n) {\n    uint32_t result = 0;\n    \n    for (int i = 0; i < 32; i++) {\n        // Extract the last bit of n\n        uint32_t bit = n & 1;\n        \n        // Shift result left and add the bit\n        result = (result << 1) | bit;\n        \n        // Shift n right to process next bit\n        n >>= 1;\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Process each of 32 bits from right to left. Extract rightmost bit of n with & 1, shift result left and OR the bit onto it, shift n right. This effectively builds the reversed number bit by bit from left to right while consuming n from right to left.",
    "timeComplexity": "O(1)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=UcoN6UjAI64",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/reverse-bits/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "climbing-stairs": {
    "id": "climbing-stairs",
    "name": "Climbing Stairs",
    "title": "Climbing Stairs",
    "category": "Dynamic Programming",
    "explanation": {
        "problemStatement": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nExample 1:\nInput: n = 2\nOutput: 2\nExplanation: (1+1), (2)\n\nExample 2:\nInput: n = 3\nOutput: 3\nExplanation: (1+1+1), (1+2), (2+1)\n\nNote: This is equivalent to computing Fibonacci numbers; you can solve with O(n) time and O(1) space.",
        "io": [],
        "constraints": [],
        "note": "This is Fibonacci sequence in disguise. To reach step n, you either came from step n-1 (1 step) or n-2 (2 steps). So ways(n) = ways(n-1) + ways(n-2). Use two variables instead of array for O(1) space. Base cases: 1 step = 1 way, 2 steps = 2 ways.",
        "steps": [],
        "useCase": "Fibonacci variations, Path counting, Dynamic programming intro",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Google",
        "Adobe"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function climbStairs(n: number): number {\n    // Base cases\n    if (n <= 2) {\n        return n;\n    }\n    \n    // Only need to track previous two values\n    let prev2 = 1;  // ways to reach step 1\n    let prev1 = 2;  // ways to reach step 2\n    \n    for (let i = 3; i <= n; i++) {\n        const current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    return prev1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def climbStairs(n: int) -> int:\n    # Base cases\n    if n <= 2:\n        return n\n    \n    # Only need to track previous two values\n    prev2 = 1  # ways to reach step 1\n    prev1 = 2  # ways to reach step 2\n    \n    for i in range(3, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int climbStairs(int n) {\n    // Base cases\n    if (n <= 2) {\n        return n;\n    }\n    \n    // Only need to track previous two values\n    int prev2 = 1;  // ways to reach step 1\n    int prev1 = 2;  // ways to reach step 2\n    \n    for (int i = 3; i <= n; i++) {\n        int current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    return prev1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int climbStairs(int n) {\n    // Base cases\n    if (n <= 2) {\n        return n;\n    }\n    \n    // Only need to track previous two values\n    int prev2 = 1;  // ways to reach step 1\n    int prev1 = 2;  // ways to reach step 2\n    \n    for (int i = 3; i <= n; i++) {\n        int current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    return prev1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "This is Fibonacci sequence in disguise. To reach step n, you either came from step n-1 (1 step) or n-2 (2 steps). So ways(n) = ways(n-1) + ways(n-2). Use two variables instead of array for O(1) space. Base cases: 1 step = 1 way, 2 steps = 2 ways.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=Y0lT9Fck7qI",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/climbing-stairs/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "coin-change": {
    "id": "coin-change",
    "name": "Coin Change",
    "title": "Coin Change",
    "category": "Dynamic Programming",
    "explanation": {
        "problemStatement": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount cannot be made up by any combination of the coins, return -1.\n\nExample 1:\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n\nExample 2:\nInput: coins = [2], amount = 3\nOutput: -1\n\nConstraints: Use DP (unbounded knapsack style) building solutions from 0→amount to get O(n × amount) time and O(amount) space.",
        "io": [],
        "constraints": [],
        "note": "Bottom-up DP. Build up solutions from 0 to amount. For each amount i, try using each coin: if coin value ≤ i, consider using it and taking the solution for (i - coin). dp[i] = min(dp[i], dp[i-coin] + 1). This is unbounded knapsack - can use same coin multiple times.",
        "steps": [],
        "useCase": "Change making, Minimum resource allocation, Unbounded knapsack",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Bloomberg"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function coinChange(coins: number[], amount: number): number {\n    // DP array: dp[i] = min coins needed for amount i\n    const dp = new Array(amount + 1).fill(amount + 1);\n    dp[0] = 0;  // 0 coins needed for amount 0\n    \n    // For each amount from 1 to target\n    for (let i = 1; i <= amount; i++) {\n        // Try each coin\n        for (const coin of coins) {\n            if (coin <= i) {\n                // Update if using this coin gives better result\n                dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n    \n    return dp[amount] > amount ? -1 : dp[amount];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def coinChange(coins: List[int], amount: int) -> int:\n    # DP array: dp[i] = min coins needed for amount i\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0  # 0 coins needed for amount 0\n    \n    # For each amount from 1 to target\n    for i in range(1, amount + 1):\n        # Try each coin\n        for coin in coins:\n            if coin <= i:\n                # Update if using this coin gives better result\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int coinChange(int[] coins, int amount) {\n    // DP array: dp[i] = min coins needed for amount i\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);  // Use amount+1 as \"infinity\"\n    dp[0] = 0;  // 0 coins needed for amount 0\n    \n    // For each amount from 1 to target\n    for (int i = 1; i <= amount; i++) {\n        // Try each coin\n        for (int coin : coins) {\n            if (coin <= i) {\n                // Update if using this coin gives better result\n                dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n    \n    return dp[amount] > amount ? -1 : dp[amount];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int coinChange(vector<int>& coins, int amount) {\n    // DP array: dp[i] = min coins needed for amount i\n    vector<int> dp(amount + 1, amount + 1);  // Use amount+1 as \"infinity\"\n    dp[0] = 0;  // 0 coins needed for amount 0\n    \n    // For each amount from 1 to target\n    for (int i = 1; i <= amount; i++) {\n        // Try each coin\n        for (int coin : coins) {\n            if (coin <= i) {\n                // Update if using this coin gives better result\n                dp[i] = min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n    \n    return dp[amount] > amount ? -1 : dp[amount];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Bottom-up DP. Build up solutions from 0 to amount. For each amount i, try using each coin: if coin value ≤ i, consider using it and taking the solution for (i - coin). dp[i] = min(dp[i], dp[i-coin] + 1). This is unbounded knapsack - can use same coin multiple times.",
    "timeComplexity": "O(n × amount)",
    "spaceComplexity": "O(amount)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=H9bfqozjoqs",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/coin-change/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "longest-increasing-subsequence": {
    "id": "longest-increasing-subsequence",
    "name": "Longest Increasing Subsequence",
    "title": "Longest Increasing Subsequence",
    "category": "Dynamic Programming",
    "explanation": {
        "problemStatement": "Given an integer array nums, return the length of the longest strictly increasing subsequence.\n\nExample 1:\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101]\n\nNote: Optimal O(n log n) solution uses patience sorting / tails array with binary search; DP is O(n²).",
        "io": [],
        "constraints": [],
        "note": "Patience sorting algorithm. Maintain array 'tails' where tails[i] is the smallest tail element of an increasing subsequence of length i+1. For each number, use binary search to find where it fits. If it's larger than all tails, append it (extending longest sequence). Otherwise, replace the first element >= num (maintaining smaller tails for potential longer sequences).",
        "steps": [],
        "useCase": "Patience sorting, Stock trading patterns, Sequence analysis",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function lengthOfLIS(nums: number[]): number {\n    // Binary search approach - O(n log n)\n    const tails: number[] = [];\n    \n    for (const num of nums) {\n        // Binary search for position to insert/replace\n        let left = 0, right = tails.length;\n        \n        while (left < right) {\n            const mid = Math.floor((left + right) / 2);\n            if (tails[mid] < num) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        \n        // If left == tails.length, append; otherwise replace\n        if (left === tails.length) {\n            tails.push(num);\n        } else {\n            tails[left] = num;\n        }\n    }\n    \n    return tails.length;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def lengthOfLIS(nums: List[int]) -> int:\n    # Binary search approach - O(n log n)\n    # tails[i] = smallest tail element of increasing subsequence of length i+1\n    tails = []\n    \n    for num in nums:\n        # Binary search for position to insert/replace\n        left, right = 0, len(tails)\n        \n        while left < right:\n            mid = (left + right) // 2\n            if tails[mid] < num:\n                left = mid + 1\n            else:\n                right = mid\n        \n        # If left == len(tails), append; otherwise replace\n        if left == len(tails):\n            tails.append(num)\n        else:\n            tails[left] = num\n    \n    return len(tails)"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int lengthOfLIS(int[] nums) {\n    // Binary search approach - O(n log n)\n    List<Integer> tails = new ArrayList<>();\n    \n    for (int num : nums) {\n        // Binary search for position to insert/replace\n        int left = 0, right = tails.size();\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (tails.get(mid) < num) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        \n        // If left == tails.size(), add; otherwise replace\n        if (left == tails.size()) {\n            tails.add(num);\n        } else {\n            tails.set(left, num);\n        }\n    }\n    \n    return tails.size();\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int lengthOfLIS(vector<int>& nums) {\n    // Binary search approach - O(n log n)\n    vector<int> tails;\n    \n    for (int num : nums) {\n        // Binary search for position to insert/replace\n        auto it = lower_bound(tails.begin(), tails.end(), num);\n        \n        // If at end, append; otherwise replace\n        if (it == tails.end()) {\n            tails.push_back(num);\n        } else {\n            *it = num;\n        }\n    }\n    \n    return tails.size();\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Patience sorting algorithm. Maintain array 'tails' where tails[i] is the smallest tail element of an increasing subsequence of length i+1. For each number, use binary search to find where it fits. If it's larger than all tails, append it (extending longest sequence). Otherwise, replace the first element >= num (maintaining smaller tails for potential longer sequences).",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=cjWnW0hdF1Y",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/longest-increasing-subsequence/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "longest-common-subsequence": {
    "id": "longest-common-subsequence",
    "name": "Longest Common Subsequence",
    "title": "Longest Common Subsequence",
    "category": "Dynamic Programming",
    "explanation": {
        "problemStatement": "Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.\n\nExample 1:\nInput: text1 = \"abcde\", text2 = \"ace\"\nOutput: 3\nExplanation: The longest common subsequence is \"ace\".\n\nNote: Typical DP builds a 2D table dp[i][j] representing LCS length for prefixes; time O(m × n) and space O(m × n) (can be optimized to O(min(m,n))).",
        "io": [],
        "constraints": [],
        "note": "Classic 2D DP. dp[i][j] represents LCS length for first i chars of text1 and first j chars of text2. If characters match, extend previous LCS by 1. If they don't match, take the better result from excluding either the current char from text1 or text2. Build table bottom-up, answer is dp[m][n].",
        "steps": [],
        "useCase": "Diff algorithms, DNA sequence alignment, Text comparison",
        "tips": []
    },
    "companyTags": [
        "Google",
        "Amazon"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function longestCommonSubsequence(text1: string, text2: string): number {\n    const m = text1.length, n = text2.length;\n    \n    // DP table: dp[i][j] = LCS length of text1[0:i] and text2[0:j]\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (text1[i - 1] === text2[j - 1]) {\n                // Characters match: extend LCS\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                // Characters don't match: take max of excluding one char\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    return dp[m][n];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def longestCommonSubsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    \n    # DP table: dp[i][j] = LCS length of text1[0:i] and text2[0:j]\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                # Characters match: extend LCS\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                # Characters don't match: take max of excluding one char\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int longestCommonSubsequence(String text1, String text2) {\n    int m = text1.length(), n = text2.length();\n    \n    // DP table: dp[i][j] = LCS length of text1[0:i] and text2[0:j]\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                // Characters match: extend LCS\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                // Characters don't match: take max of excluding one char\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    return dp[m][n];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int longestCommonSubsequence(string text1, string text2) {\n    int m = text1.length(), n = text2.length();\n    \n    // DP table: dp[i][j] = LCS length of text1[0:i] and text2[0:j]\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1[i - 1] == text2[j - 1]) {\n                // Characters match: extend LCS\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                // Characters don't match: take max of excluding one char\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    return dp[m][n];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Classic 2D DP. dp[i][j] represents LCS length for first i chars of text1 and first j chars of text2. If characters match, extend previous LCS by 1. If they don't match, take the better result from excluding either the current char from text1 or text2. Build table bottom-up, answer is dp[m][n].",
    "timeComplexity": "O(m × n)",
    "spaceComplexity": "O(m × n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=Ua0GhsJSlWM",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/longest-common-subsequence/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "word-break-problem": {
    "id": "word-break-problem",
    "name": "Word Break Problem",
    "title": "Word Break Problem",
    "category": "Dynamic Programming",
    "explanation": {
        "problemStatement": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\n\nExample 1:\nInput: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true\n\nExample 2:\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\nOutput: true\n\nConstraints: Use DP with a boolean dp array where dp[i] indicates whether s[0:i] can be segmented; optimize with a Trie or limiting check lengths for speed.",
        "io": [],
        "constraints": [],
        "note": "DP approach. dp[i] = true if substring s[0:i] can be segmented. For each position i, check all possible splits: if s[0:j] can be segmented (dp[j]=true) and s[j:i] is in dictionary, then s[0:i] can be segmented. Convert wordDict to set for O(1) lookup. Time: O(n² × m) where m is average word length.",
        "steps": [],
        "useCase": "Text tokenization, String segmentation, Dictionary lookup",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Google"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function wordBreak(s: string, wordDict: string[]): boolean {\n    const wordSet = new Set(wordDict);\n    const n = s.length;\n    \n    // dp[i] = true if s.substring(0, i) can be segmented\n    const dp = new Array(n + 1).fill(false);\n    dp[0] = true;  // Empty string can be segmented\n    \n    for (let i = 1; i <= n; i++) {\n        // Check all possible last words\n        for (let j = 0; j < i; j++) {\n            // If s[0:j] can be segmented and s[j:i] is in dict\n            if (dp[j] && wordSet.has(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    \n    return dp[n];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def wordBreak(s: str, wordDict: List[str]) -> bool:\n    word_set = set(wordDict)\n    n = len(s)\n    \n    # dp[i] = True if s[0:i] can be segmented\n    dp = [False] * (n + 1)\n    dp[0] = True  # Empty string can be segmented\n    \n    for i in range(1, n + 1):\n        # Check all possible last words\n        for j in range(i):\n            # If s[0:j] can be segmented and s[j:i] is in dict\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    \n    return dp[n]"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean wordBreak(String s, List<String> wordDict) {\n    Set<String> wordSet = new HashSet<>(wordDict);\n    int n = s.length();\n    \n    // dp[i] = true if s.substring(0, i) can be segmented\n    boolean[] dp = new boolean[n + 1];\n    dp[0] = true;  // Empty string can be segmented\n    \n    for (int i = 1; i <= n; i++) {\n        // Check all possible last words\n        for (int j = 0; j < i; j++) {\n            // If s[0:j] can be segmented and s[j:i] is in dict\n            if (dp[j] && wordSet.contains(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    \n    return dp[n];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool wordBreak(string s, vector<string>& wordDict) {\n    unordered_set<string> wordSet(wordDict.begin(), wordDict.end());\n    int n = s.length();\n    \n    // dp[i] = true if s.substr(0, i) can be segmented\n    vector<bool> dp(n + 1, false);\n    dp[0] = true;  // Empty string can be segmented\n    \n    for (int i = 1; i <= n; i++) {\n        // Check all possible last words\n        for (int j = 0; j < i; j++) {\n            // If s[0:j] can be segmented and s[j:i] is in dict\n            if (dp[j] && wordSet.count(s.substr(j, i - j))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    \n    return dp[n];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "DP approach. dp[i] = true if substring s[0:i] can be segmented. For each position i, check all possible splits: if s[0:j] can be segmented (dp[j]=true) and s[j:i] is in dictionary, then s[0:i] can be segmented. Convert wordDict to set for O(1) lookup. Time: O(n² × m) where m is average word length.",
    "timeComplexity": "O(n²)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=Sx9NNgInc3A",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/word-break/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "combination-sum": {
    "id": "combination-sum",
    "name": "Combination Sum",
    "title": "Combination Sum",
    "category": "Dynamic Programming",
    "explanation": {
        "problemStatement": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target.\n\nYou may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 for the given input.\n\nExample:\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\n\nConstraints:\n• 1 <= candidates.length <= 30\n• 1 <= candidates[i] <= 200\n• All elements of candidates are distinct\n• 1 <= target <= 500",
        "io": [],
        "constraints": [],
        "note": "Use backtracking to explore all combinations. Key insight: since we can reuse elements, pass current index 'i' (not i+1) in recursion. Sort candidates first for optimization (optional). Prune branches when total exceeds target.",
        "steps": [],
        "useCase": "Subset problems, Backtracking patterns, Combinatorial search",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function combinationSum(candidates: number[], target: number): number[][] {\n    const result: number[][] = [];\n    \n    function backtrack(start: number, current: number[], total: number) {\n        // Base case: found valid combination\n        if (total === target) {\n            result.push([...current]);\n            return;\n        }\n        \n        // Base case: exceeded target\n        if (total > target) {\n            return;\n        }\n        \n        // Try each candidate starting from 'start' index\n        for (let i = start; i < candidates.length; i++) {\n            current.push(candidates[i]);\n            // Can reuse same element, so pass 'i' not 'i+1'\n            backtrack(i, current, total + candidates[i]);\n            current.pop();\n        }\n    }\n    \n    backtrack(0, [], 0);\n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n    result = []\n    \n    def backtrack(start, current, total):\n        # Base case: found valid combination\n        if total == target:\n            result.append(current[:])\n            return\n        \n        # Base case: exceeded target\n        if total > target:\n            return\n        \n        # Try each candidate starting from 'start' index\n        for i in range(start, len(candidates)):\n            current.append(candidates[i])\n            # Can reuse same element, so pass 'i' not 'i+1'\n            backtrack(i, current, total + candidates[i])\n            current.pop()\n    \n    backtrack(0, [], 0)\n    return result"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrack(candidates, target, 0, new ArrayList<>(), 0, result);\n    return result;\n}\n\nprivate void backtrack(int[] candidates, int target, int start, \n                       List<Integer> current, int total, \n                       List<List<Integer>> result) {\n    // Base case: found valid combination\n    if (total == target) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n    \n    // Base case: exceeded target\n    if (total > target) {\n        return;\n    }\n    \n    // Try each candidate starting from 'start' index\n    for (int i = start; i < candidates.length; i++) {\n        current.add(candidates[i]);\n        // Can reuse same element, so pass 'i' not 'i+1'\n        backtrack(candidates, target, i, current, total + candidates[i], result);\n        current.remove(current.size() - 1);\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n    vector<vector<int>> result;\n    vector<int> current;\n    backtrack(candidates, target, 0, current, 0, result);\n    return result;\n}\n\nvoid backtrack(vector<int>& candidates, int target, int start, \n               vector<int>& current, int total, \n               vector<vector<int>>& result) {\n    // Base case: found valid combination\n    if (total == target) {\n        result.push_back(current);\n        return;\n    }\n    \n    // Base case: exceeded target\n    if (total > target) {\n        return;\n    }\n    \n    // Try each candidate starting from 'start' index\n    for (int i = start; i < candidates.size(); i++) {\n        current.push_back(candidates[i]);\n        // Can reuse same element, so pass 'i' not 'i+1'\n        backtrack(candidates, target, i, current, total + candidates[i], result);\n        current.pop_back();\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use backtracking to explore all combinations. Key insight: since we can reuse elements, pass current index 'i' (not i+1) in recursion. Sort candidates first for optimization (optional). Prune branches when total exceeds target.",
    "timeComplexity": "O(n^(target/minCandidate + 1)) (worst-case backtracking)",
    "spaceComplexity": "O(target/minCandidate) + output size",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=GBKI9VSKdGg",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/combination-sum/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "house-robber": {
    "id": "house-robber",
    "name": "House Robber",
    "title": "House Robber",
    "category": "Dynamic Programming",
    "explanation": {
        "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. Adjacent houses have security systems connected that will alert the police if two adjacent houses are broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\nExample:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob houses with values 2, 9, 1 (or 7, 3, 1) depending on indices.\n\nConstraints:\n• 1 <= nums.length <= 100\n• 0 <= nums[i] <= 400\n\nNote: A common DP solution uses dp[i] = max(dp[i-1], dp[i-2] + nums[i]) and can be optimized to O(1) space by tracking two variables.",
        "io": [],
        "constraints": [],
        "note": "DP pattern: at each house, decide to rob (add current + best from i-2) or skip (keep best from i-1). Use two variables instead of array for O(1) space. Formula: dp[i] = max(nums[i] + dp[i-2], dp[i-1]).",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "LinkedIn"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function rob(nums: number[]): number {\n    if (nums.length === 0) return 0;\n    if (nums.length === 1) return nums[0];\n    \n    // Track max money from two previous houses\n    let prev2 = 0;  // i-2\n    let prev1 = 0;  // i-1\n    \n    for (const num of nums) {\n        // Either rob current + i-2, or skip current (take i-1)\n        const temp = Math.max(num + prev2, prev1);\n        prev2 = prev1;\n        prev1 = temp;\n    }\n    \n    return prev1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def rob(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    # Track max money from two previous houses\n    prev2 = 0  # i-2\n    prev1 = 0  # i-1\n    \n    for num in nums:\n        # Either rob current + i-2, or skip current (take i-1)\n        temp = max(num + prev2, prev1)\n        prev2 = prev1\n        prev1 = temp\n    \n    return prev1"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int rob(int[] nums) {\n    if (nums.length == 0) return 0;\n    if (nums.length == 1) return nums[0];\n    \n    // Track max money from two previous houses\n    int prev2 = 0;  // i-2\n    int prev1 = 0;  // i-1\n    \n    for (int num : nums) {\n        // Either rob current + i-2, or skip current (take i-1)\n        int temp = Math.max(num + prev2, prev1);\n        prev2 = prev1;\n        prev1 = temp;\n    }\n    \n    return prev1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int rob(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    if (nums.size() == 1) return nums[0];\n    \n    // Track max money from two previous houses\n    int prev2 = 0;  // i-2\n    int prev1 = 0;  // i-1\n    \n    for (int num : nums) {\n        // Either rob current + i-2, or skip current (take i-1)\n        int temp = max(num + prev2, prev1);\n        prev2 = prev1;\n        prev1 = temp;\n    }\n    \n    return prev1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "DP pattern: at each house, decide to rob (add current + best from i-2) or skip (keep best from i-1). Use two variables instead of array for O(1) space. Formula: dp[i] = max(nums[i] + dp[i-2], dp[i-1]).",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=73r3KWiEvyk",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/house-robber/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "house-robber-ii": {
    "id": "house-robber-ii",
    "name": "House Robber II",
    "title": "House Robber II",
    "category": "Dynamic Programming",
    "explanation": {
        "problemStatement": "All houses are arranged in a circle. That means the first house is the neighbor of the last one. Adjacent houses cannot both be robbed.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob without alerting the police.\n\nBecause of the circular arrangement, you cannot rob both the first and last houses; the typical approach splits into two linear cases: rob houses from index 0..n-2 or 1..n-1 and take the max.\n\nExample:\nInput: nums = [2,3,2]\nOutput: 3\n\nConstraints:\n• 1 <= nums.length <= 100\n• 0 <= nums[i] <= 1000",
        "io": [],
        "constraints": [],
        "note": "Houses are circular: can't rob both first and last. Split into two cases: (1) rob houses 0..n-2, (2) rob houses 1..n-1. Apply House Robber I logic to each case and take maximum.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function rob(nums: number[]): number {\n    if (nums.length === 1) return nums[0];\n    \n    const robLinear = (start: number, end: number): number => {\n        let prev2 = 0, prev1 = 0;\n        for (let i = start; i <= end; i++) {\n            const temp = Math.max(nums[i] + prev2, prev1);\n            prev2 = prev1;\n            prev1 = temp;\n        }\n        return prev1;\n    };\n    \n    // Case 1: Rob houses 0 to n-2 (exclude last)\n    // Case 2: Rob houses 1 to n-1 (exclude first)\n    return Math.max(robLinear(0, nums.length - 2),\n                    robLinear(1, nums.length - 1));\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def rob(nums: List[int]) -> int:\n    if len(nums) == 1:\n        return nums[0]\n    \n    # Helper function from House Robber I\n    def rob_linear(houses):\n        prev2, prev1 = 0, 0\n        for num in houses:\n            temp = max(num + prev2, prev1)\n            prev2 = prev1\n            prev1 = temp\n        return prev1\n    \n    # Case 1: Rob houses 0 to n-2 (exclude last)\n    # Case 2: Rob houses 1 to n-1 (exclude first)\n    return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int rob(int[] nums) {\n    if (nums.length == 1) return nums[0];\n    \n    // Case 1: Rob houses 0 to n-2 (exclude last)\n    // Case 2: Rob houses 1 to n-1 (exclude first)\n    return Math.max(robLinear(nums, 0, nums.length - 2),\n                    robLinear(nums, 1, nums.length - 1));\n}\n\nprivate int robLinear(int[] nums, int start, int end) {\n    int prev2 = 0, prev1 = 0;\n    for (int i = start; i <= end; i++) {\n        int temp = Math.max(nums[i] + prev2, prev1);\n        prev2 = prev1;\n        prev1 = temp;\n    }\n    return prev1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int rob(vector<int>& nums) {\n    if (nums.size() == 1) return nums[0];\n    \n    // Case 1: Rob houses 0 to n-2 (exclude last)\n    // Case 2: Rob houses 1 to n-1 (exclude first)\n    return max(robLinear(nums, 0, nums.size() - 2),\n               robLinear(nums, 1, nums.size() - 1));\n}\n\nint robLinear(vector<int>& nums, int start, int end) {\n    int prev2 = 0, prev1 = 0;\n    for (int i = start; i <= end; i++) {\n        int temp = max(nums[i] + prev2, prev1);\n        prev2 = prev1;\n        prev1 = temp;\n    }\n    return prev1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Houses are circular: can't rob both first and last. Split into two cases: (1) rob houses 0..n-2, (2) rob houses 1..n-1. Apply House Robber I logic to each case and take maximum.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=rWAJCfYYOvM",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/house-robber-ii/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "decode-ways": {
    "id": "decode-ways",
    "name": "Decode Ways",
    "title": "Decode Ways",
    "category": "Dynamic Programming",
    "explanation": {
        "problemStatement": "A message containing letters from A–Z can be encoded into numbers using the mapping 'A' -> \"1\", 'B' -> \"2\", ..., 'Z' -> \"26\".\n\nGiven a string s containing only digits, return the number of ways to decode it. The answer is guaranteed to fit in a 32-bit integer.\n\nExample:\nInput: s = \"12\"\nOutput: 2\nExplanation: \"AB\" or \"L\".\n\nInput: s = \"226\"\nOutput: 3\nExplanation: \"BZ\", \"VF\", \"BBF\".\n\nConstraints:\n• 1 <= s.length <= 100\n• s contains only digits and may include '0' which has special handling (e.g., '0' cannot be decoded alone).\n\nTypical DP recurrence: ways[i] = ways[i-1] (if s[i] is valid single-digit) + ways[i-2] (if s[i-1..i] is a valid two-digit decode between 10 and 26).",
        "io": [],
        "constraints": [],
        "note": "DP: at position i, we can decode as single digit (if 1-9) using dp[i-1] ways, or as two digits (if 10-26) using dp[i-2] ways. Handle '0' carefully - it can only be part of 10 or 20. Optimize to O(1) space with two variables.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Google"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function numDecodings(s: string): number {\n    if (!s || s[0] === '0') {\n        return 0;\n    }\n    \n    const n = s.length;\n    let prev2 = 1;  // dp[i-2]\n    let prev1 = 1;  // dp[i-1]\n    \n    for (let i = 1; i < n; i++) {\n        let current = 0;\n        \n        // Single digit decode (1-9)\n        if (s[i] !== '0') {\n            current += prev1;\n        }\n        \n        // Two digit decode (10-26)\n        const twoDigit = parseInt(s.substring(i-1, i+1));\n        if (twoDigit >= 10 && twoDigit <= 26) {\n            current += prev2;\n        }\n        \n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    return prev1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def numDecodings(s: str) -> int:\n    if not s or s[0] == '0':\n        return 0\n    \n    # dp[i] = number of ways to decode s[:i]\n    n = len(s)\n    prev2 = 1  # dp[i-2]\n    prev1 = 1  # dp[i-1]\n    \n    for i in range(1, n):\n        current = 0\n        \n        # Single digit decode (1-9)\n        if s[i] != '0':\n            current += prev1\n        \n        # Two digit decode (10-26)\n        two_digit = int(s[i-1:i+1])\n        if 10 <= two_digit <= 26:\n            current += prev2\n        \n        prev2 = prev1\n        prev1 = current\n    \n    return prev1"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int numDecodings(String s) {\n    if (s == null || s.length() == 0 || s.charAt(0) == '0') {\n        return 0;\n    }\n    \n    int n = s.length();\n    int prev2 = 1;  // dp[i-2]\n    int prev1 = 1;  // dp[i-1]\n    \n    for (int i = 1; i < n; i++) {\n        int current = 0;\n        \n        // Single digit decode (1-9)\n        if (s.charAt(i) != '0') {\n            current += prev1;\n        }\n        \n        // Two digit decode (10-26)\n        int twoDigit = Integer.parseInt(s.substring(i-1, i+1));\n        if (twoDigit >= 10 && twoDigit <= 26) {\n            current += prev2;\n        }\n        \n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    return prev1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int numDecodings(string s) {\n    if (s.empty() || s[0] == '0') {\n        return 0;\n    }\n    \n    int n = s.length();\n    int prev2 = 1;  // dp[i-2]\n    int prev1 = 1;  // dp[i-1]\n    \n    for (int i = 1; i < n; i++) {\n        int current = 0;\n        \n        // Single digit decode (1-9)\n        if (s[i] != '0') {\n            current += prev1;\n        }\n        \n        // Two digit decode (10-26)\n        int twoDigit = stoi(s.substr(i-1, 2));\n        if (twoDigit >= 10 && twoDigit <= 26) {\n            current += prev2;\n        }\n        \n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    return prev1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "DP: at position i, we can decode as single digit (if 1-9) using dp[i-1] ways, or as two digits (if 10-26) using dp[i-2] ways. Handle '0' carefully - it can only be part of 10 or 20. Optimize to O(1) space with two variables.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=6aEyTjOwlJU",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/decode-ways/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "unique-paths": {
    "id": "unique-paths",
    "name": "Unique Paths",
    "title": "Unique Paths",
    "category": "Dynamic Programming",
    "explanation": {
        "problemStatement": "There is a robot on an m × n grid. The robot is initially located at the top-left corner (0, 0). The robot tries to move to the bottom-right corner (m-1, n-1). The robot can only move either down or right at any point in time.\n\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\nExample:\nInput: m = 3, n = 7\nOutput: 28\n\nConstraints:\n• 1 <= m, n <= 100\n\nSolutions: DP with dp[i][j] = dp[i-1][j] + dp[i][j-1] or combinatorics using binomial coefficients C(m+n-2, m-1). Time: O(m × n).",
        "io": [],
        "constraints": [],
        "note": "2D DP: dp[i][j] = paths to reach cell (i,j). Since we can only move right or down, dp[i][j] = dp[i-1][j] + dp[i][j-1]. First row and column are all 1s. Can optimize to O(n) space using 1D array.",
        "steps": [],
        "useCase": "Grid path counting, Robot navigation, Combinatorics",
        "tips": []
    },
    "companyTags": [
        "Google",
        "Bloomberg"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function uniquePaths(m: number, n: number): number {\n    // Create DP table\n    const dp: number[][] = Array(m).fill(0).map(() => Array(n).fill(1));\n    \n    // Fill DP table\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            // Paths from top + paths from left\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        }\n    }\n    \n    return dp[m-1][n-1];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def uniquePaths(m: int, n: int) -> int:\n    # Create DP table\n    dp = [[1] * n for _ in range(m)]\n    \n    # Fill DP table\n    for i in range(1, m):\n        for j in range(1, n):\n            # Paths from top + paths from left\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int uniquePaths(int m, int n) {\n    // Create DP table\n    int[][] dp = new int[m][n];\n    \n    // Initialize first row and column\n    for (int i = 0; i < m; i++) dp[i][0] = 1;\n    for (int j = 0; j < n; j++) dp[0][j] = 1;\n    \n    // Fill DP table\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            // Paths from top + paths from left\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        }\n    }\n    \n    return dp[m-1][n-1];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int uniquePaths(int m, int n) {\n    // Create DP table\n    vector<vector<int>> dp(m, vector<int>(n, 1));\n    \n    // Fill DP table\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            // Paths from top + paths from left\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        }\n    }\n    \n    return dp[m-1][n-1];\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "2D DP: dp[i][j] = paths to reach cell (i,j). Since we can only move right or down, dp[i][j] = dp[i-1][j] + dp[i][j-1]. First row and column are all 1s. Can optimize to O(n) space using 1D array.",
    "timeComplexity": "O(m × n)",
    "spaceComplexity": "O(m × n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=IlEsdxuD4lY",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/unique-paths/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "jump-game": {
    "id": "jump-game",
    "name": "Jump Game",
    "title": "Jump Game",
    "category": "Dynamic Programming",
    "explanation": {
        "problemStatement": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn true if you can reach the last index, or false otherwise.\n\nExample:\nInput: nums = [2,3,1,1,4]\nOutput: true\n\nInput: nums = [3,2,1,0,4]\nOutput: false\n\nConstraints:\n• 1 <= nums.length <= 10^4\n• 0 <= nums[i] <= 10^5\n\nCommon greedy solution: track the farthest reachable index while iterating; if at any index i the farthest reachable index < i, return false.",
        "io": [],
        "constraints": [],
        "note": "Greedy approach: track the farthest index reachable. At each position, if current index > maxReach, we're stuck. Otherwise, update maxReach = max(maxReach, i + nums[i]). If maxReach >= last index, return true.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft",
        "Google"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function canJump(nums: number[]): boolean {\n    // Track the farthest position we can reach\n    let maxReach = 0;\n    \n    for (let i = 0; i < nums.length; i++) {\n        // If current position is beyond max reach, can't proceed\n        if (i > maxReach) {\n            return false;\n        }\n        \n        // Update max reach from current position\n        maxReach = Math.max(maxReach, i + nums[i]);\n        \n        // Early exit if we can reach the end\n        if (maxReach >= nums.length - 1) {\n            return true;\n        }\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def canJump(nums: List[int]) -> bool:\n    # Track the farthest position we can reach\n    max_reach = 0\n    \n    for i in range(len(nums)):\n        # If current position is beyond max reach, can't proceed\n        if i > max_reach:\n            return False\n        \n        # Update max reach from current position\n        max_reach = max(max_reach, i + nums[i])\n        \n        # Early exit if we can reach the end\n        if max_reach >= len(nums) - 1:\n            return True\n    \n    return True"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean canJump(int[] nums) {\n    // Track the farthest position we can reach\n    int maxReach = 0;\n    \n    for (int i = 0; i < nums.length; i++) {\n        // If current position is beyond max reach, can't proceed\n        if (i > maxReach) {\n            return false;\n        }\n        \n        // Update max reach from current position\n        maxReach = Math.max(maxReach, i + nums[i]);\n        \n        // Early exit if we can reach the end\n        if (maxReach >= nums.length - 1) {\n            return true;\n        }\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool canJump(vector<int>& nums) {\n    // Track the farthest position we can reach\n    int maxReach = 0;\n    \n    for (int i = 0; i < nums.size(); i++) {\n        // If current position is beyond max reach, can't proceed\n        if (i > maxReach) {\n            return false;\n        }\n        \n        // Update max reach from current position\n        maxReach = max(maxReach, i + nums[i]);\n        \n        // Early exit if we can reach the end\n        if (maxReach >= nums.size() - 1) {\n            return true;\n        }\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Greedy approach: track the farthest index reachable. At each position, if current index > maxReach, we're stuck. Otherwise, update maxReach = max(maxReach, i + nums[i]). If maxReach >= last index, return true.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=Yan0cv2cLy8",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/jump-game/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "clone-graph": {
    "id": "clone-graph",
    "name": "Clone Graph",
    "title": "Clone Graph",
    "category": "Graph",
    "explanation": {
        "problemStatement": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a value and a list (or array) of its neighbors. You must return the cloned node corresponding to the given node.\n\nThe graph is represented using adjacency lists and each node's value is unique.\n\nExample:\nInput: adjacency list = [[2,4],[1,3],[2,4],[1,3]]\nOutput: deep copy of the same adjacency structure.\n\nConstraints:\n• 1 <= number of nodes <= 100\n• Node values are 1..100\n\nTypical solutions: use DFS or BFS with a hashmap mapping original node -> cloned node to avoid revisiting nodes and to handle cycles.",
        "io": [],
        "constraints": [],
        "note": "Use DFS with a hashmap to track original->clone mappings. For each node: if already cloned, return clone; otherwise create new node, store mapping, then recursively clone all neighbors. BFS works similarly with a queue.",
        "steps": [],
        "useCase": "Deep copying, Graph traversal, Object cloning",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon",
        "Google"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function cloneGraph(node: Node | null): Node | null {\n    if (!node) return null;\n    \n    // Map original node to cloned node\n    const cloned = new Map<Node, Node>();\n    \n    function dfs(node: Node): Node {\n        // If already cloned, return the clone\n        if (cloned.has(node)) {\n            return cloned.get(node)!;\n        }\n        \n        // Create clone of current node\n        const clone = new Node(node.val);\n        cloned.set(node, clone);\n        \n        // Clone all neighbors recursively\n        for (const neighbor of node.neighbors) {\n            clone.neighbors.push(dfs(neighbor));\n        }\n        \n        return clone;\n    }\n    \n    return dfs(node);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def cloneGraph(node: 'Node') -> 'Node':\n    if not node:\n        return None\n    \n    # Map original node to cloned node\n    cloned = {}\n    \n    def dfs(node):\n        # If already cloned, return the clone\n        if node in cloned:\n            return cloned[node]\n        \n        # Create clone of current node\n        clone = Node(node.val)\n        cloned[node] = clone\n        \n        # Clone all neighbors recursively\n        for neighbor in node.neighbors:\n            clone.neighbors.append(dfs(neighbor))\n        \n        return clone\n    \n    return dfs(node)"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public Node cloneGraph(Node node) {\n    if (node == null) return null;\n    \n    // Map original node to cloned node\n    Map<Node, Node> cloned = new HashMap<>();\n    return dfs(node, cloned);\n}\n\nprivate Node dfs(Node node, Map<Node, Node> cloned) {\n    // If already cloned, return the clone\n    if (cloned.containsKey(node)) {\n        return cloned.get(node);\n    }\n    \n    // Create clone of current node\n    Node clone = new Node(node.val);\n    cloned.put(node, clone);\n    \n    // Clone all neighbors recursively\n    for (Node neighbor : node.neighbors) {\n        clone.neighbors.add(dfs(neighbor, cloned));\n    }\n    \n    return clone;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "Node* cloneGraph(Node* node) {\n    if (!node) return nullptr;\n    \n    // Map original node to cloned node\n    unordered_map<Node*, Node*> cloned;\n    return dfs(node, cloned);\n}\n\nNode* dfs(Node* node, unordered_map<Node*, Node*>& cloned) {\n    // If already cloned, return the clone\n    if (cloned.count(node)) {\n        return cloned[node];\n    }\n    \n    // Create clone of current node\n    Node* clone = new Node(node->val);\n    cloned[node] = clone;\n    \n    // Clone all neighbors recursively\n    for (Node* neighbor : node->neighbors) {\n        clone->neighbors.push_back(dfs(neighbor, cloned));\n    }\n    \n    return clone;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use DFS with a hashmap to track original->clone mappings. For each node: if already cloned, return clone; otherwise create new node, store mapping, then recursively clone all neighbors. BFS works similarly with a queue.",
    "timeComplexity": "O(V + E)",
    "spaceComplexity": "O(V)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=mQeF6bN8hMk",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/clone-graph/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "course-schedule": {
    "id": "course-schedule",
    "name": "Course Schedule",
    "title": "Course Schedule",
    "category": "Graph",
    "explanation": {
        "problemStatement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nReturn true if you can finish all courses. Otherwise, return false. This is equivalent to detecting whether the directed graph of prerequisites contains a cycle.\n\nExample:\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\n\nConstraints:\n• 1 <= numCourses <= 10^5\n• 0 <= prerequisites.length <= 10^5\n\nTypical approaches: Kahn's algorithm (topological sort / indegree) or DFS cycle detection.",
        "io": [],
        "constraints": [],
        "note": "Cycle detection in directed graph using DFS. Use 3 states: unvisited(0), visiting(1), visited(2). If we encounter a node in 'visiting' state during DFS, there's a cycle. Build adjacency list from prerequisites and check all nodes.",
        "steps": [],
        "useCase": "Cycle detection, Topological sorting, Dependency resolution",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Google"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function canFinish(numCourses: number, prerequisites: number[][]): boolean {\n    // Build adjacency list\n    const graph: number[][] = Array(numCourses).fill(0).map(() => []);\n    for (const [course, prereq] of prerequisites) {\n        graph[course].push(prereq);\n    }\n    \n    // Track visit states: 0=unvisited, 1=visiting, 2=visited\n    const visit: number[] = Array(numCourses).fill(0);\n    \n    function hasCycle(course: number): boolean {\n        if (visit[course] === 1) return true;   // Cycle detected\n        if (visit[course] === 2) return false;  // Already processed\n        \n        visit[course] = 1;  // Mark as visiting\n        for (const prereq of graph[course]) {\n            if (hasCycle(prereq)) {\n                return true;\n            }\n        }\n        visit[course] = 2;  // Mark as visited\n        return false;\n    }\n    \n    // Check for cycles in each component\n    for (let course = 0; course < numCourses; course++) {\n        if (hasCycle(course)) {\n            return false;\n        }\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n    # Build adjacency list\n    graph = [[] for _ in range(numCourses)]\n    for course, prereq in prerequisites:\n        graph[course].append(prereq)\n    \n    # Track visit states: 0=unvisited, 1=visiting, 2=visited\n    visit = [0] * numCourses\n    \n    def has_cycle(course):\n        if visit[course] == 1:  # Cycle detected\n            return True\n        if visit[course] == 2:  # Already processed\n            return False\n        \n        visit[course] = 1  # Mark as visiting\n        for prereq in graph[course]:\n            if has_cycle(prereq):\n                return True\n        visit[course] = 2  # Mark as visited\n        return False\n    \n    # Check for cycles in each component\n    for course in range(numCourses):\n        if has_cycle(course):\n            return False\n    \n    return True"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean canFinish(int numCourses, int[][] prerequisites) {\n    // Build adjacency list\n    List<List<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i < numCourses; i++) {\n        graph.add(new ArrayList<>());\n    }\n    for (int[] prereq : prerequisites) {\n        graph.get(prereq[0]).add(prereq[1]);\n    }\n    \n    // Track visit states: 0=unvisited, 1=visiting, 2=visited\n    int[] visit = new int[numCourses];\n    \n    // Check for cycles in each component\n    for (int course = 0; course < numCourses; course++) {\n        if (hasCycle(course, graph, visit)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nprivate boolean hasCycle(int course, List<List<Integer>> graph, int[] visit) {\n    if (visit[course] == 1) return true;   // Cycle detected\n    if (visit[course] == 2) return false;  // Already processed\n    \n    visit[course] = 1;  // Mark as visiting\n    for (int prereq : graph.get(course)) {\n        if (hasCycle(prereq, graph, visit)) {\n            return true;\n        }\n    }\n    visit[course] = 2;  // Mark as visited\n    return false;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    // Build adjacency list\n    vector<vector<int>> graph(numCourses);\n    for (auto& prereq : prerequisites) {\n        graph[prereq[0]].push_back(prereq[1]);\n    }\n    \n    // Track visit states: 0=unvisited, 1=visiting, 2=visited\n    vector<int> visit(numCourses, 0);\n    \n    function<bool(int)> hasCycle = [&](int course) {\n        if (visit[course] == 1) return true;   // Cycle detected\n        if (visit[course] == 2) return false;  // Already processed\n        \n        visit[course] = 1;  // Mark as visiting\n        for (int prereq : graph[course]) {\n            if (hasCycle(prereq)) {\n                return true;\n            }\n        }\n        visit[course] = 2;  // Mark as visited\n        return false;\n    };\n    \n    // Check for cycles in each component\n    for (int course = 0; course < numCourses; course++) {\n        if (hasCycle(course)) {\n            return false;\n        }\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Cycle detection in directed graph using DFS. Use 3 states: unvisited(0), visiting(1), visited(2). If we encounter a node in 'visiting' state during DFS, there's a cycle. Build adjacency list from prerequisites and check all nodes.",
    "timeComplexity": "O(V + E)",
    "spaceComplexity": "O(V + E)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=EgI5nU9etnU",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/course-schedule/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "pacific-atlantic-water-flow": {
    "id": "pacific-atlantic-water-flow",
    "name": "Pacific Atlantic Water Flow",
    "title": "Pacific Atlantic Water Flow",
    "category": "Graph",
    "explanation": {
        "problemStatement": "There is an m × n rectangular grid heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c). The island touches both the Pacific and Atlantic oceans: the Pacific ocean touches the island's left and top edges, and the Atlantic ocean touches the island's right and bottom edges.\n\nWater can only flow from a cell to neighboring cells (north, south, east, west) with height less than or equal to the current cell's height. Return a list of grid coordinates where water can flow to both the Pacific and Atlantic oceans.\n\nExample:\nInput:\nheights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n\nConstraints:\n• 1 <= m, n <= 200\n\nStandard solution: run two BFS/DFS traversals from the ocean borders (one for Pacific, one for Atlantic) marking reachable cells and return cells reachable in both.",
        "io": [],
        "constraints": [],
        "note": "Reverse thinking: instead of checking if water flows to oceans from each cell, DFS from ocean borders inward (water can flow uphill in reverse). Mark cells reachable from Pacific and Atlantic. Cells in both sets can reach both oceans.",
        "steps": [],
        "useCase": "Water flow simulation, Multi-source BFS/DFS, Grid traversal",
        "tips": []
    },
    "companyTags": [
        "Google",
        "Amazon"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function pacificAtlantic(heights: number[][]): number[][] {\n    if (!heights.length) return [];\n    \n    const m = heights.length, n = heights[0].length;\n    const pacific = Array(m).fill(0).map(() => Array(n).fill(false));\n    const atlantic = Array(m).fill(0).map(() => Array(n).fill(false));\n    \n    function dfs(r: number, c: number, visited: boolean[][]) {\n        visited[r][c] = true;\n        const dirs = [[0,1], [0,-1], [1,0], [-1,0]];\n        for (const [dr, dc] of dirs) {\n            const nr = r + dr, nc = c + dc;\n            if (nr >= 0 && nr < m && nc >= 0 && nc < n &&\n                !visited[nr][nc] && heights[nr][nc] >= heights[r][c]) {\n                dfs(nr, nc, visited);\n            }\n        }\n    }\n    \n    // DFS from borders\n    for (let i = 0; i < m; i++) {\n        dfs(i, 0, pacific);\n        dfs(i, n-1, atlantic);\n    }\n    for (let j = 0; j < n; j++) {\n        dfs(0, j, pacific);\n        dfs(m-1, j, atlantic);\n    }\n    \n    // Find intersection\n    const result: number[][] = [];\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (pacific[i][j] && atlantic[i][j]) {\n                result.push([i, j]);\n            }\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def pacificAtlantic(heights: List[List[int]]) -> List[List[int]]:\n    if not heights:\n        return []\n    \n    m, n = len(heights), len(heights[0])\n    pacific = set()\n    atlantic = set()\n    \n    def dfs(r, c, visited, prev_height):\n        if (r < 0 or r >= m or c < 0 or c >= n or\n            (r, c) in visited or heights[r][c] < prev_height):\n            return\n        \n        visited.add((r, c))\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            dfs(r + dr, c + dc, visited, heights[r][c])\n    \n    # DFS from Pacific borders (top and left)\n    for i in range(m):\n        dfs(i, 0, pacific, heights[i][0])\n    for j in range(n):\n        dfs(0, j, pacific, heights[0][j])\n    \n    # DFS from Atlantic borders (bottom and right)\n    for i in range(m):\n        dfs(i, n-1, atlantic, heights[i][n-1])\n    for j in range(n):\n        dfs(m-1, j, atlantic, heights[m-1][j])\n    \n    # Find cells reachable by both oceans\n    return [[r, c] for r in range(m) for c in range(n) \n            if (r, c) in pacific and (r, c) in atlantic]"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public List<List<Integer>> pacificAtlantic(int[][] heights) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (heights == null || heights.length == 0) return result;\n    \n    int m = heights.length, n = heights[0].length;\n    boolean[][] pacific = new boolean[m][n];\n    boolean[][] atlantic = new boolean[m][n];\n    \n    // DFS from Pacific borders\n    for (int i = 0; i < m; i++) {\n        dfs(heights, pacific, i, 0);\n    }\n    for (int j = 0; j < n; j++) {\n        dfs(heights, pacific, 0, j);\n    }\n    \n    // DFS from Atlantic borders\n    for (int i = 0; i < m; i++) {\n        dfs(heights, atlantic, i, n-1);\n    }\n    for (int j = 0; j < n; j++) {\n        dfs(heights, atlantic, m-1, j);\n    }\n    \n    // Find cells reachable by both oceans\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (pacific[i][j] && atlantic[i][j]) {\n                result.add(Arrays.asList(i, j));\n            }\n        }\n    }\n    \n    return result;\n}\n\nprivate void dfs(int[][] heights, boolean[][] visited, int r, int c) {\n    int m = heights.length, n = heights[0].length;\n    visited[r][c] = true;\n    \n    int[][] dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\n    for (int[] dir : dirs) {\n        int nr = r + dir[0], nc = c + dir[1];\n        if (nr >= 0 && nr < m && nc >= 0 && nc < n &&\n            !visited[nr][nc] && heights[nr][nc] >= heights[r][c]) {\n            dfs(heights, visited, nr, nc);\n        }\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n    vector<vector<int>> result;\n    if (heights.empty()) return result;\n    \n    int m = heights.size(), n = heights[0].size();\n    vector<vector<bool>> pacific(m, vector<bool>(n, false));\n    vector<vector<bool>> atlantic(m, vector<bool>(n, false));\n    \n    function<void(int, int, vector<vector<bool>>&)> dfs = \n        [&](int r, int c, vector<vector<bool>>& visited) {\n        visited[r][c] = true;\n        vector<pair<int,int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\n        for (auto [dr, dc] : dirs) {\n            int nr = r + dr, nc = c + dc;\n            if (nr >= 0 && nr < m && nc >= 0 && nc < n &&\n                !visited[nr][nc] && heights[nr][nc] >= heights[r][c]) {\n                dfs(nr, nc, visited);\n            }\n        }\n    };\n    \n    // DFS from borders\n    for (int i = 0; i < m; i++) {\n        dfs(i, 0, pacific);\n        dfs(i, n-1, atlantic);\n    }\n    for (int j = 0; j < n; j++) {\n        dfs(0, j, pacific);\n        dfs(m-1, j, atlantic);\n    }\n    \n    // Find intersection\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (pacific[i][j] && atlantic[i][j]) {\n                result.push_back({i, j});\n            }\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Reverse thinking: instead of checking if water flows to oceans from each cell, DFS from ocean borders inward (water can flow uphill in reverse). Mark cells reachable from Pacific and Atlantic. Cells in both sets can reach both oceans.",
    "timeComplexity": "O(m × n)",
    "spaceComplexity": "O(m × n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=s-VkcjHqkGI",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/pacific-atlantic-water-flow/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "number-of-islands": {
    "id": "number-of-islands",
    "name": "Number of Islands",
    "title": "Number of Islands",
    "category": "Graph",
    "explanation": {
        "problemStatement": "Given an m × n 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n\nExample:\nInput:\ngrid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\nOutput: 3\n\nConstraints:\n• m == grid.length\n• n == grid[i].length\n• 1 <= m, n <= 300\n• grid[i][j] is '0' or '1'\n\nTypical solutions: DFS or BFS flood-fill to mark visited land, or Union-Find.",
        "io": [],
        "constraints": [],
        "note": "For each unvisited land cell ('1'), increment island count and DFS to mark entire connected island as visited (change to '0'). This flood-fill approach ensures each connected component is counted once. Can use BFS or Union-Find as alternatives.",
        "steps": [],
        "useCase": "Connected components, Flood fill, Image processing",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Microsoft"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function numIslands(grid: string[][]): number {\n    if (!grid.length) return 0;\n    \n    const m = grid.length, n = grid[0].length;\n    let count = 0;\n    \n    function dfs(r: number, c: number) {\n        if (r < 0 || r >= m || c < 0 || c >= n || grid[r][c] !== '1') {\n            return;\n        }\n        \n        // Mark as visited\n        grid[r][c] = '0';\n        \n        // Visit all 4 directions\n        dfs(r+1, c);\n        dfs(r-1, c);\n        dfs(r, c+1);\n        dfs(r, c-1);\n    }\n    \n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === '1') {\n                count++;\n                dfs(i, j);  // Sink the island\n            }\n        }\n    }\n    \n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def numIslands(grid: List[List[str]]) -> int:\n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    count = 0\n    \n    def dfs(r, c):\n        if (r < 0 or r >= m or c < 0 or c >= n or \n            grid[r][c] != '1'):\n            return\n        \n        # Mark as visited by changing to '0'\n        grid[r][c] = '0'\n        \n        # Visit all 4 directions\n        dfs(r+1, c)\n        dfs(r-1, c)\n        dfs(r, c+1)\n        dfs(r, c-1)\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)  # Sink the island\n    \n    return count"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0) return 0;\n    \n    int m = grid.length, n = grid[0].length;\n    int count = 0;\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == '1') {\n                count++;\n                dfs(grid, i, j);  // Sink the island\n            }\n        }\n    }\n    \n    return count;\n}\n\nprivate void dfs(char[][] grid, int r, int c) {\n    int m = grid.length, n = grid[0].length;\n    if (r < 0 || r >= m || c < 0 || c >= n || grid[r][c] != '1') {\n        return;\n    }\n    \n    // Mark as visited\n    grid[r][c] = '0';\n    \n    // Visit all 4 directions\n    dfs(grid, r+1, c);\n    dfs(grid, r-1, c);\n    dfs(grid, r, c+1);\n    dfs(grid, r, c-1);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int numIslands(vector<vector<char>>& grid) {\n    if (grid.empty()) return 0;\n    \n    int m = grid.size(), n = grid[0].size();\n    int count = 0;\n    \n    function<void(int, int)> dfs = [&](int r, int c) {\n        if (r < 0 || r >= m || c < 0 || c >= n || grid[r][c] != '1') {\n            return;\n        }\n        \n        // Mark as visited\n        grid[r][c] = '0';\n        \n        // Visit all 4 directions\n        dfs(r+1, c);\n        dfs(r-1, c);\n        dfs(r, c+1);\n        dfs(r, c-1);\n    };\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == '1') {\n                count++;\n                dfs(i, j);  // Sink the island\n            }\n        }\n    }\n    \n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "For each unvisited land cell ('1'), increment island count and DFS to mark entire connected island as visited (change to '0'). This flood-fill approach ensures each connected component is counted once. Can use BFS or Union-Find as alternatives.",
    "timeComplexity": "O(m × n)",
    "spaceComplexity": "O(m × n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=pV2kpPD66nE",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/number-of-islands/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "longest-consecutive-sequence": {
    "id": "longest-consecutive-sequence",
    "name": "Longest Consecutive Sequence",
    "title": "Longest Consecutive Sequence",
    "category": "Graph",
    "explanation": {
        "problemStatement": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.\n\nExample:\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive sequence is [1,2,3,4].\n\nConstraints:\n• Use a hash set to allow O(1) checks for sequence starts and expand from starts to get O(n) time.",
        "io": [],
        "constraints": [],
        "note": "Use hash set for O(1) lookups. Key insight: only start counting from sequence beginnings (when num-1 not in set). This ensures each number is visited at most twice, achieving O(n) time despite nested loops.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Google",
        "Facebook"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function longestConsecutive(nums: number[]): number {\n    if (nums.length === 0) return 0;\n    \n    const numSet = new Set(nums);\n    let maxLength = 0;\n    \n    for (const num of numSet) {\n        // Only start sequence from the smallest number\n        if (!numSet.has(num - 1)) {\n            let current = num;\n            let length = 1;\n            \n            // Count consecutive numbers\n            while (numSet.has(current + 1)) {\n                current++;\n                length++;\n            }\n            \n            maxLength = Math.max(maxLength, length);\n        }\n    }\n    \n    return maxLength;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def longestConsecutive(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    num_set = set(nums)\n    max_length = 0\n    \n    for num in num_set:\n        # Only start sequence from the smallest number\n        if num - 1 not in num_set:\n            current = num\n            length = 1\n            \n            # Count consecutive numbers\n            while current + 1 in num_set:\n                current += 1\n                length += 1\n            \n            max_length = max(max_length, length)\n    \n    return max_length"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int longestConsecutive(int[] nums) {\n    if (nums.length == 0) return 0;\n    \n    Set<Integer> numSet = new HashSet<>();\n    for (int num : nums) {\n        numSet.add(num);\n    }\n    \n    int maxLength = 0;\n    \n    for (int num : numSet) {\n        // Only start sequence from the smallest number\n        if (!numSet.contains(num - 1)) {\n            int current = num;\n            int length = 1;\n            \n            // Count consecutive numbers\n            while (numSet.contains(current + 1)) {\n                current++;\n                length++;\n            }\n            \n            maxLength = Math.max(maxLength, length);\n        }\n    }\n    \n    return maxLength;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int longestConsecutive(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    \n    unordered_set<int> numSet(nums.begin(), nums.end());\n    int maxLength = 0;\n    \n    for (int num : numSet) {\n        // Only start sequence from the smallest number\n        if (numSet.find(num - 1) == numSet.end()) {\n            int current = num;\n            int length = 1;\n            \n            // Count consecutive numbers\n            while (numSet.find(current + 1) != numSet.end()) {\n                current++;\n                length++;\n            }\n            \n            maxLength = max(maxLength, length);\n        }\n    }\n    \n    return maxLength;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use hash set for O(1) lookups. Key insight: only start counting from sequence beginnings (when num-1 not in set). This ensures each number is visited at most twice, achieving O(n) time despite nested loops.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=P6RZZMu_maU",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "alien-dictionary": {
    "id": "alien-dictionary",
    "name": "Alien Dictionary (Leetcode Premium)",
    "title": "Alien Dictionary (Leetcode Premium)",
    "category": "Graph",
    "explanation": {
        "problemStatement": "There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.\n\nYou are given a list of strings words from the alien language's dictionary, where the strings in words are sorted lexicographically by the rules of this new language. Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If the ordering is invalid, return \"\".\n\nExample:\nInput: words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]\nOutput: \"wertf\"\n\nConstraints:\n• Typical time: O(V + E) where V = number of unique letters and E = constraints between letters\n\nNotes: build a graph of letter orderings and perform topological sort; detect cycles for invalid ordering.",
        "io": [],
        "constraints": [],
        "note": "Build directed graph from adjacent word pairs: first differing character creates edge (c1 -> c2 means c1 before c2). Use topological sort (Kahn's algorithm) with indegree tracking. Invalid if result length ≠ unique chars (cycle exists).",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Google",
        "Airbnb"
    ],
    "difficulty": "advance",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function alienOrder(words: string[]): string {\n    // Build graph\n    const graph = new Map<string, Set<string>>();\n    const indegree = new Map<string, number>();\n    \n    for (const word of words) {\n        for (const c of word) {\n            if (!graph.has(c)) {\n                graph.set(c, new Set());\n                indegree.set(c, 0);\n            }\n        }\n    }\n    \n    // Find ordering\n    for (let i = 0; i < words.length - 1; i++) {\n        const w1 = words[i], w2 = words[i+1];\n        const minLen = Math.min(w1.length, w2.length);\n        \n        if (w1.length > w2.length && w1.startsWith(w2)) {\n            return \"\";\n        }\n        \n        for (let j = 0; j < minLen; j++) {\n            if (w1[j] !== w2[j]) {\n                if (!graph.get(w1[j])!.has(w2[j])) {\n                    graph.get(w1[j])!.add(w2[j]);\n                    indegree.set(w2[j], indegree.get(w2[j])! + 1);\n                }\n                break;\n            }\n        }\n    }\n    \n    // Topological sort\n    const queue: string[] = [];\n    for (const [c, deg] of indegree) {\n        if (deg === 0) queue.push(c);\n    }\n    \n    let result = \"\";\n    while (queue.length) {\n        const c = queue.shift()!;\n        result += c;\n        \n        for (const neighbor of graph.get(c)!) {\n            indegree.set(neighbor, indegree.get(neighbor)! - 1);\n            if (indegree.get(neighbor) === 0) {\n                queue.push(neighbor);\n            }\n        }\n    }\n    \n    return result.length === indegree.size ? result : \"\";\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def alienOrder(words: List[str]) -> str:\n    # Build graph and indegree\n    graph = {c: set() for word in words for c in word}\n    indegree = {c: 0 for word in words for c in word}\n    \n    # Compare adjacent words to find ordering\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i+1]\n        min_len = min(len(w1), len(w2))\n        \n        # Check for invalid case: prefix word comes after longer word\n        if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:\n            return \"\"\n        \n        # Find first differing character\n        for j in range(min_len):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n    \n    while queue:\n        char = queue.popleft()\n        result.append(char)\n        \n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check for cycle\n    if len(result) != len(indegree):\n        return \"\"\n    \n    return ''.join(result)"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public String alienOrder(String[] words) {\n    // Build graph\n    Map<Character, Set<Character>> graph = new HashMap<>();\n    Map<Character, Integer> indegree = new HashMap<>();\n    \n    for (String word : words) {\n        for (char c : word.toCharArray()) {\n            graph.putIfAbsent(c, new HashSet<>());\n            indegree.putIfAbsent(c, 0);\n        }\n    }\n    \n    // Find ordering from adjacent words\n    for (int i = 0; i < words.length - 1; i++) {\n        String w1 = words[i], w2 = words[i+1];\n        int minLen = Math.min(w1.length(), w2.length());\n        \n        if (w1.length() > w2.length() && w1.startsWith(w2)) {\n            return \"\";\n        }\n        \n        for (int j = 0; j < minLen; j++) {\n            if (w1.charAt(j) != w2.charAt(j)) {\n                char from = w1.charAt(j), to = w2.charAt(j);\n                if (!graph.get(from).contains(to)) {\n                    graph.get(from).add(to);\n                    indegree.put(to, indegree.get(to) + 1);\n                }\n                break;\n            }\n        }\n    }\n    \n    // Topological sort\n    Queue<Character> queue = new LinkedList<>();\n    for (char c : indegree.keySet()) {\n        if (indegree.get(c) == 0) {\n            queue.offer(c);\n        }\n    }\n    \n    StringBuilder result = new StringBuilder();\n    while (!queue.isEmpty()) {\n        char c = queue.poll();\n        result.append(c);\n        \n        for (char neighbor : graph.get(c)) {\n            indegree.put(neighbor, indegree.get(neighbor) - 1);\n            if (indegree.get(neighbor) == 0) {\n                queue.offer(neighbor);\n            }\n        }\n    }\n    \n    return result.length() == indegree.size() ? result.toString() : \"\";\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "string alienOrder(vector<string>& words) {\n    // Build graph\n    unordered_map<char, unordered_set<char>> graph;\n    unordered_map<char, int> indegree;\n    \n    for (const string& word : words) {\n        for (char c : word) {\n            graph[c] = {};\n            indegree[c] = 0;\n        }\n    }\n    \n    // Find ordering\n    for (int i = 0; i < words.size() - 1; i++) {\n        string w1 = words[i], w2 = words[i+1];\n        int minLen = min(w1.length(), w2.length());\n        \n        if (w1.length() > w2.length() && w1.substr(0, minLen) == w2) {\n            return \"\";\n        }\n        \n        for (int j = 0; j < minLen; j++) {\n            if (w1[j] != w2[j]) {\n                if (graph[w1[j]].find(w2[j]) == graph[w1[j]].end()) {\n                    graph[w1[j]].insert(w2[j]);\n                    indegree[w2[j]]++;\n                }\n                break;\n            }\n        }\n    }\n    \n    // Topological sort\n    queue<char> q;\n    for (auto& [c, deg] : indegree) {\n        if (deg == 0) q.push(c);\n    }\n    \n    string result;\n    while (!q.empty()) {\n        char c = q.front();\n        q.pop();\n        result += c;\n        \n        for (char neighbor : graph[c]) {\n            if (--indegree[neighbor] == 0) {\n                q.push(neighbor);\n            }\n        }\n    }\n    \n    return result.length() == indegree.size() ? result : \"\";\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Build directed graph from adjacent word pairs: first differing character creates edge (c1 -> c2 means c1 before c2). Use topological sort (Kahn's algorithm) with indegree tracking. Invalid if result length ≠ unique chars (cycle exists).",
    "timeComplexity": "O(C) (≈ O(V + E))",
    "spaceComplexity": "O(V + E)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=6kTZYvNNyps",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "advance",
                "url": "https://leetcode.com/problems/alien-dictionary/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "graph-valid-tree": {
    "id": "graph-valid-tree",
    "name": "Graph Valid Tree (Leetcode Premium)",
    "title": "Graph Valid Tree (Leetcode Premium)",
    "category": "Graph",
    "explanation": {
        "problemStatement": "You have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.\n\nReturn true if the edges of the given graph make up a valid tree, and false otherwise. A valid tree must be connected and contain no cycles.\n\nExample:\nInput: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]\nOutput: true\n\nTypical approaches: check that edges = n-1 and graph is connected (via DFS/BFS) or use Union-Find to detect cycles and connectivity.",
        "io": [],
        "constraints": [],
        "note": "A valid tree with n nodes must have exactly n-1 edges (no cycles) and be fully connected. Check: (1) edges.length === n-1, (2) all nodes reachable from any starting node via DFS/BFS. Union-Find alternative checks for cycles during edge addition.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Google",
        "Amazon"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function validTree(n: number, edges: number[][]): boolean {\n    // Tree must have exactly n-1 edges\n    if (edges.length !== n - 1) {\n        return false;\n    }\n    \n    // Build adjacency list\n    const graph: number[][] = Array(n).fill(0).map(() => []);\n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    \n    // Check if graph is connected using DFS\n    const visited = new Set<number>();\n    \n    function dfs(node: number) {\n        visited.add(node);\n        for (const neighbor of graph[node]) {\n            if (!visited.has(neighbor)) {\n                dfs(neighbor);\n            }\n        }\n    }\n    \n    dfs(0);\n    \n    // Valid tree if all nodes are visited\n    return visited.size === n;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def validTree(n: int, edges: List[List[int]]) -> bool:\n    # Tree must have exactly n-1 edges\n    if len(edges) != n - 1:\n        return False\n    \n    # Build adjacency list\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Check if graph is connected using DFS\n    visited = set()\n    \n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n    \n    dfs(0)\n    \n    # Valid tree if all nodes are visited\n    return len(visited) == n"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean validTree(int n, int[][] edges) {\n    // Tree must have exactly n-1 edges\n    if (edges.length != n - 1) {\n        return false;\n    }\n    \n    // Build adjacency list\n    List<List<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        graph.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        graph.get(edge[0]).add(edge[1]);\n        graph.get(edge[1]).add(edge[0]);\n    }\n    \n    // Check if graph is connected using DFS\n    Set<Integer> visited = new HashSet<>();\n    dfs(0, graph, visited);\n    \n    // Valid tree if all nodes are visited\n    return visited.size() == n;\n}\n\nprivate void dfs(int node, List<List<Integer>> graph, Set<Integer> visited) {\n    visited.add(node);\n    for (int neighbor : graph.get(node)) {\n        if (!visited.contains(neighbor)) {\n            dfs(neighbor, graph, visited);\n        }\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool validTree(int n, vector<vector<int>>& edges) {\n    // Tree must have exactly n-1 edges\n    if (edges.size() != n - 1) {\n        return false;\n    }\n    \n    // Build adjacency list\n    vector<vector<int>> graph(n);\n    for (auto& edge : edges) {\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }\n    \n    // Check if graph is connected using DFS\n    unordered_set<int> visited;\n    \n    function<void(int)> dfs = [&](int node) {\n        visited.insert(node);\n        for (int neighbor : graph[node]) {\n            if (visited.find(neighbor) == visited.end()) {\n                dfs(neighbor);\n            }\n        }\n    };\n    \n    dfs(0);\n    \n    // Valid tree if all nodes are visited\n    return visited.size() == n;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "A valid tree with n nodes must have exactly n-1 edges (no cycles) and be fully connected. Check: (1) edges.length === n-1, (2) all nodes reachable from any starting node via DFS/BFS. Union-Find alternative checks for cycles during edge addition.",
    "timeComplexity": "O(V + E)",
    "spaceComplexity": "O(V + E)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=bXsUuownnoQ",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/graph-valid-tree/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "number-of-connected-components-in-an-undirected-graph": {
    "id": "number-of-connected-components-in-an-undirected-graph",
    "name": "Number of Connected Components in an Undirected Graph (Leetcode Premium)",
    "title": "Number of Connected Components in an Undirected Graph (Leetcode Premium)",
    "category": "Graph",
    "explanation": {
        "problemStatement": "You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph.\n\nReturn the number of connected components in the graph.\n\nExample:\nInput: n = 5, edges = [[0,1],[1,2],[3,4]]\nOutput: 2\n\nTypical solutions: DFS/BFS to count components or Union-Find for efficient union operations.",
        "io": [],
        "constraints": [],
        "note": "Build adjacency list from edges. For each unvisited node, start DFS to mark entire component as visited, increment count. Union-Find is more efficient for dynamic graphs with frequent connectivity queries.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Google"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function countComponents(n: number, edges: number[][]): number {\n    // Build adjacency list\n    const graph: number[][] = Array(n).fill(0).map(() => []);\n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    \n    const visited = new Set<number>();\n    let count = 0;\n    \n    function dfs(node: number) {\n        visited.add(node);\n        for (const neighbor of graph[node]) {\n            if (!visited.has(neighbor)) {\n                dfs(neighbor);\n            }\n        }\n    }\n    \n    // Count components by DFS\n    for (let i = 0; i < n; i++) {\n        if (!visited.has(i)) {\n            dfs(i);\n            count++;\n        }\n    }\n    \n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def countComponents(n: int, edges: List[List[int]]) -> int:\n    # Build adjacency list\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = set()\n    count = 0\n    \n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n    \n    # Count components by DFS\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            count += 1\n    \n    return count"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int countComponents(int n, int[][] edges) {\n    // Build adjacency list\n    List<List<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        graph.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        graph.get(edge[0]).add(edge[1]);\n        graph.get(edge[1]).add(edge[0]);\n    }\n    \n    boolean[] visited = new boolean[n];\n    int count = 0;\n    \n    // Count components by DFS\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, graph, visited);\n            count++;\n        }\n    }\n    \n    return count;\n}\n\nprivate void dfs(int node, List<List<Integer>> graph, boolean[] visited) {\n    visited[node] = true;\n    for (int neighbor : graph.get(node)) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, graph, visited);\n        }\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int countComponents(int n, vector<vector<int>>& edges) {\n    // Build adjacency list\n    vector<vector<int>> graph(n);\n    for (auto& edge : edges) {\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }\n    \n    vector<bool> visited(n, false);\n    int count = 0;\n    \n    function<void(int)> dfs = [&](int node) {\n        visited[node] = true;\n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n            }\n        }\n    };\n    \n    // Count components by DFS\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n            count++;\n        }\n    }\n    \n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Build adjacency list from edges. For each unvisited node, start DFS to mark entire component as visited, increment count. Union-Find is more efficient for dynamic graphs with frequent connectivity queries.",
    "timeComplexity": "O(V + E)",
    "spaceComplexity": "O(V + E)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=8f1XPm4WOUc",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "insert-interval": {
    "id": "insert-interval",
    "name": "Insert Interval",
    "title": "Insert Interval",
    "category": "Interval",
    "explanation": {
        "problemStatement": "You are given an array of non-overlapping intervals where intervals[i] = [starti, endi] represent the start and the end of the i-th interval and intervals is sorted in ascending order by starti.\n\nYou are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge if necessary).\n\nExample:\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]",
        "io": [],
        "constraints": [],
        "note": "Three-phase approach: (1) Add all intervals ending before newInterval starts, (2) Merge all overlapping intervals by expanding newInterval's bounds, (3) Add remaining intervals. Linear scan in O(n) time since intervals are pre-sorted.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Google",
        "LinkedIn"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function insert(intervals: number[][], newInterval: number[]): number[][] {\n    const result: number[][] = [];\n    let i = 0;\n    const n = intervals.length;\n    \n    // Add all intervals before newInterval\n    while (i < n && intervals[i][1] < newInterval[0]) {\n        result.push(intervals[i]);\n        i++;\n    }\n    \n    // Merge overlapping intervals\n    while (i < n && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    result.push(newInterval);\n    \n    // Add remaining intervals\n    while (i < n) {\n        result.push(intervals[i]);\n        i++;\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n    result = []\n    i = 0\n    n = len(intervals)\n    \n    # Add all intervals before newInterval\n    while i < n and intervals[i][1] < newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n    \n    # Merge overlapping intervals\n    while i < n and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    result.append(newInterval)\n    \n    # Add remaining intervals\n    while i < n:\n        result.append(intervals[i])\n        i += 1\n    \n    return result"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int[][] insert(int[][] intervals, int[] newInterval) {\n    List<int[]> result = new ArrayList<>();\n    int i = 0, n = intervals.length;\n    \n    // Add all intervals before newInterval\n    while (i < n && intervals[i][1] < newInterval[0]) {\n        result.add(intervals[i]);\n        i++;\n    }\n    \n    // Merge overlapping intervals\n    while (i < n && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    result.add(newInterval);\n    \n    // Add remaining intervals\n    while (i < n) {\n        result.add(intervals[i]);\n        i++;\n    }\n    \n    return result.toArray(new int[result.size()][]);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n    vector<vector<int>> result;\n    int i = 0, n = intervals.size();\n    \n    // Add all intervals before newInterval\n    while (i < n && intervals[i][1] < newInterval[0]) {\n        result.push_back(intervals[i]);\n        i++;\n    }\n    \n    // Merge overlapping intervals\n    while (i < n && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = min(newInterval[0], intervals[i][0]);\n        newInterval[1] = max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    result.push_back(newInterval);\n    \n    // Add remaining intervals\n    while (i < n) {\n        result.push_back(intervals[i]);\n        i++;\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Three-phase approach: (1) Add all intervals ending before newInterval starts, (2) Merge all overlapping intervals by expanding newInterval's bounds, (3) Add remaining intervals. Linear scan in O(n) time since intervals are pre-sorted.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=A8NUOmlwOlM",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/insert-interval/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "merge-intervals": {
    "id": "merge-intervals",
    "name": "Merge Intervals",
    "title": "Merge Intervals",
    "category": "Interval",
    "explanation": {
        "problemStatement": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nExample:\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]",
        "io": [],
        "constraints": [],
        "note": "Sort intervals by start time. Iterate through sorted intervals: if current overlaps with last result (start <= last end), merge them by updating end time. Otherwise add as new interval. O(n log n) for sorting.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon",
        "Google"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function merge(intervals: number[][]): number[][] {\n    if (!intervals.length) return [];\n    \n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    const result: number[][] = [intervals[0]];\n    \n    for (let i = 1; i < intervals.length; i++) {\n        const [start, end] = intervals[i];\n        const lastEnd = result[result.length - 1][1];\n        \n        if (start <= lastEnd) {\n            // Overlapping, merge\n            result[result.length - 1][1] = Math.max(lastEnd, end);\n        } else {\n            // No overlap, add new interval\n            result.push([start, end]);\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def merge(intervals: List[List[int]]) -> List[List[int]]:\n    if not intervals:\n        return []\n    \n    # Sort by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    result = [intervals[0]]\n    \n    for start, end in intervals[1:]:\n        last_end = result[-1][1]\n        \n        if start <= last_end:\n            # Overlapping, merge\n            result[-1][1] = max(last_end, end)\n        else:\n            # No overlap, add new interval\n            result.append([start, end])\n    \n    return result"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int[][] merge(int[][] intervals) {\n    if (intervals.length == 0) return new int[0][];\n    \n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    \n    List<int[]> result = new ArrayList<>();\n    result.add(intervals[0]);\n    \n    for (int i = 1; i < intervals.length; i++) {\n        int[] current = intervals[i];\n        int[] last = result.get(result.size() - 1);\n        \n        if (current[0] <= last[1]) {\n            // Overlapping, merge\n            last[1] = Math.max(last[1], current[1]);\n        } else {\n            // No overlap, add new interval\n            result.add(current);\n        }\n    }\n    \n    return result.toArray(new int[result.size()][]);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\n    if (intervals.empty()) return {};\n    \n    sort(intervals.begin(), intervals.end());\n    \n    vector<vector<int>> result;\n    result.push_back(intervals[0]);\n    \n    for (int i = 1; i < intervals.size(); i++) {\n        if (intervals[i][0] <= result.back()[1]) {\n            // Overlapping, merge\n            result.back()[1] = max(result.back()[1], intervals[i][1]);\n        } else {\n            // No overlap, add new interval\n            result.push_back(intervals[i]);\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Sort intervals by start time. Iterate through sorted intervals: if current overlaps with last result (start <= last end), merge them by updating end time. Otherwise add as new interval. O(n log n) for sorting.",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=44H3cEC2fFM",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/merge-intervals/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "non-overlapping-intervals": {
    "id": "non-overlapping-intervals",
    "name": "Non-overlapping Intervals",
    "title": "Non-overlapping Intervals",
    "category": "Interval",
    "explanation": {
        "problemStatement": "Given an array of intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\nNote: intervals that only touch at a point are non-overlapping.\n\nExample:\nInput: intervals = [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1",
        "io": [],
        "constraints": [],
        "note": "Greedy approach: sort by end time and keep intervals that don't overlap. By always keeping the interval with earliest end time, we maximize room for future intervals. Count overlaps as removals.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function eraseOverlapIntervals(intervals: number[][]): number {\n    // Sort by end time\n    intervals.sort((a, b) => a[1] - b[1]);\n    \n    let count = 0;\n    let end = -Infinity;\n    \n    for (const [start, currEnd] of intervals) {\n        if (start >= end) {\n            // No overlap, keep this interval\n            end = currEnd;\n        } else {\n            // Overlap detected, remove one interval\n            count++;\n        }\n    }\n    \n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def eraseOverlapIntervals(intervals: List[List[int]]) -> int:\n    # Sort by end time\n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    end = float('-inf')\n    \n    for start, curr_end in intervals:\n        if start >= end:\n            # No overlap, keep this interval\n            end = curr_end\n        else:\n            # Overlap detected, remove one interval\n            count += 1\n    \n    return count"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int eraseOverlapIntervals(int[][] intervals) {\n    // Sort by end time\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));\n    \n    int count = 0;\n    int end = Integer.MIN_VALUE;\n    \n    for (int[] interval : intervals) {\n        if (interval[0] >= end) {\n            // No overlap, keep this interval\n            end = interval[1];\n        } else {\n            // Overlap detected, remove one interval\n            count++;\n        }\n    }\n    \n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n    // Sort by end time\n    sort(intervals.begin(), intervals.end(), \n         [](const vector<int>& a, const vector<int>& b) {\n             return a[1] < b[1];\n         });\n    \n    int count = 0;\n    int end = INT_MIN;\n    \n    for (const auto& interval : intervals) {\n        if (interval[0] >= end) {\n            // No overlap, keep this interval\n            end = interval[1];\n        } else {\n            // Overlap detected, remove one interval\n            count++;\n        }\n    }\n    \n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Greedy approach: sort by end time and keep intervals that don't overlap. By always keeping the interval with earliest end time, we maximize room for future intervals. Count overlaps as removals.",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=nONCGxWoUfM",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/non-overlapping-intervals/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "meeting-rooms": {
    "id": "meeting-rooms",
    "name": "Meeting Rooms (Leetcode Premium)",
    "title": "Meeting Rooms (Leetcode Premium)",
    "category": "Interval",
    "explanation": {
        "problemStatement": "Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings (i.e., the intervals do not overlap).\n\nExample:\nInput: intervals = [[0,30],[5,10],[15,20]]\nOutput: false\n\nTypical approach: sort intervals by start time and check for overlaps.",
        "io": [],
        "constraints": [],
        "note": "Sort meetings by start time. If any meeting starts before the previous one ends, there's an overlap and we can't attend all meetings. Simple O(n log n) solution.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function canAttendMeetings(intervals: number[][]): boolean {\n    // Sort intervals by start time\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    // Check for overlaps\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < intervals[i-1][1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def canAttendMeetings(intervals: List[List[int]]) -> bool:\n    # Sort intervals by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    # Check for overlaps\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return False\n    \n    return True"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean canAttendMeetings(int[][] intervals) {\n    // Sort intervals by start time\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    \n    // Check for overlaps\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < intervals[i-1][1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool canAttendMeetings(vector<vector<int>>& intervals) {\n    // Sort intervals by start time\n    sort(intervals.begin(), intervals.end());\n    \n    // Check for overlaps\n    for (int i = 1; i < intervals.size(); i++) {\n        if (intervals[i][0] < intervals[i-1][1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Sort meetings by start time. If any meeting starts before the previous one ends, there's an overlap and we can't attend all meetings. Simple O(n log n) solution.",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=PaJxqZVPhbg&t=67s",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/meeting-rooms/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "meeting-rooms-ii": {
    "id": "meeting-rooms-ii",
    "name": "Meeting Rooms II (Leetcode Premium)",
    "title": "Meeting Rooms II (Leetcode Premium)",
    "category": "Interval",
    "explanation": {
        "problemStatement": "Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.\n\nExample:\nInput: intervals = [[0,30],[5,10],[15,20]]\nOutput: 2\n\nTypical approach: sort by start time and use a min-heap of end times or two-pointer sweep.",
        "io": [],
        "constraints": [],
        "note": "Two-pointer sweep line algorithm: separate and sort start/end times. When a meeting starts before another ends, we need an additional room. Track maximum concurrent meetings needed.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon",
        "Google"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function minMeetingRooms(intervals: number[][]): number {\n    if (intervals.length === 0) return 0;\n    \n    const start = intervals.map(i => i[0]).sort((a, b) => a - b);\n    const end = intervals.map(i => i[1]).sort((a, b) => a - b);\n    \n    let rooms = 0, maxRooms = 0;\n    let s = 0, e = 0;\n    \n    while (s < intervals.length) {\n        if (start[s] < end[e]) {\n            rooms++;\n            maxRooms = Math.max(maxRooms, rooms);\n            s++;\n        } else {\n            rooms--;\n            e++;\n        }\n    }\n    \n    return maxRooms;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def minMeetingRooms(intervals: List[List[int]]) -> int:\n    if not intervals:\n        return 0\n    \n    # Separate start and end times\n    start_times = sorted([i[0] for i in intervals])\n    end_times = sorted([i[1] for i in intervals])\n    \n    rooms = 0\n    max_rooms = 0\n    s = e = 0\n    \n    # Two-pointer approach\n    while s < len(intervals):\n        if start_times[s] < end_times[e]:\n            # Meeting starts, need a room\n            rooms += 1\n            max_rooms = max(max_rooms, rooms)\n            s += 1\n        else:\n            # Meeting ends, free a room\n            rooms -= 1\n            e += 1\n    \n    return max_rooms"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int minMeetingRooms(int[][] intervals) {\n    if (intervals.length == 0) return 0;\n    \n    int n = intervals.length;\n    int[] start = new int[n];\n    int[] end = new int[n];\n    \n    for (int i = 0; i < n; i++) {\n        start[i] = intervals[i][0];\n        end[i] = intervals[i][1];\n    }\n    \n    Arrays.sort(start);\n    Arrays.sort(end);\n    \n    int rooms = 0, maxRooms = 0;\n    int s = 0, e = 0;\n    \n    while (s < n) {\n        if (start[s] < end[e]) {\n            rooms++;\n            maxRooms = Math.max(maxRooms, rooms);\n            s++;\n        } else {\n            rooms--;\n            e++;\n        }\n    }\n    \n    return maxRooms;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int minMeetingRooms(vector<vector<int>>& intervals) {\n    if (intervals.empty()) return 0;\n    \n    vector<int> start, end;\n    for (const auto& interval : intervals) {\n        start.push_back(interval[0]);\n        end.push_back(interval[1]);\n    }\n    \n    sort(start.begin(), start.end());\n    sort(end.begin(), end.end());\n    \n    int rooms = 0, maxRooms = 0;\n    int s = 0, e = 0;\n    \n    while (s < intervals.size()) {\n        if (start[s] < end[e]) {\n            rooms++;\n            maxRooms = max(maxRooms, rooms);\n            s++;\n        } else {\n            rooms--;\n            e++;\n        }\n    }\n    \n    return maxRooms;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Two-pointer sweep line algorithm: separate and sort start/end times. When a meeting starts before another ends, we need an additional room. Track maximum concurrent meetings needed.",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=FdzJmTCVyJU",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/meeting-rooms-ii/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "reverse-linked-list": {
    "id": "reverse-linked-list",
    "name": "Reverse a Linked List",
    "title": "Reverse a Linked List",
    "category": "Linked List",
    "explanation": {
        "problemStatement": "Given the head of a singly linked list, reverse the list, and return the reversed list.\n\nExample:\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n\nApproaches: iterative pointer reversal (prev, curr, next) or recursion.",
        "io": [],
        "constraints": [],
        "note": "Use three pointers: prev, current, and next. Iterate through the list, reversing the link direction by pointing current.next to prev. Move all pointers one step forward until we reach the end.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft",
        "Apple"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function reverseList(head: ListNode | null): ListNode | null {\n    let prev: ListNode | null = null;\n    let current = head;\n    \n    while (current !== null) {\n        // Save next node\n        const nextNode = current.next;\n        \n        // Reverse the link\n        current.next = prev;\n        \n        // Move pointers forward\n        prev = current;\n        current = nextNode;\n    }\n    \n    return prev;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def reverseList(head: Optional[ListNode]) -> Optional[ListNode]:\n    prev = None\n    current = head\n    \n    while current:\n        # Save next node\n        next_node = current.next\n        \n        # Reverse the link\n        current.next = prev\n        \n        # Move pointers forward\n        prev = current\n        current = next_node\n    \n    return prev"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public ListNode reverseList(ListNode head) {\n    ListNode prev = null;\n    ListNode current = head;\n    \n    while (current != null) {\n        // Save next node\n        ListNode nextNode = current.next;\n        \n        // Reverse the link\n        current.next = prev;\n        \n        // Move pointers forward\n        prev = current;\n        current = nextNode;\n    }\n    \n    return prev;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "ListNode* reverseList(ListNode* head) {\n    ListNode* prev = nullptr;\n    ListNode* current = head;\n    \n    while (current != nullptr) {\n        // Save next node\n        ListNode* nextNode = current->next;\n        \n        // Reverse the link\n        current->next = prev;\n        \n        // Move pointers forward\n        prev = current;\n        current = nextNode;\n    }\n    \n    return prev;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use three pointers: prev, current, and next. Iterate through the list, reversing the link direction by pointing current.next to prev. Move all pointers one step forward until we reach the end.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=G0_I-ZF0S38",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/reverse-linked-list/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "detect-cycle-in-a-linked-list": {
    "id": "detect-cycle-in-a-linked-list",
    "name": "Detect Cycle in a Linked List",
    "title": "Detect Cycle in a Linked List",
    "category": "Linked List",
    "explanation": {
        "problemStatement": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer.\n\nExample:\nInput: head = [3,2,0,-4] with pos = 1\nOutput: true\n\nTypical solution: Floyd's Tortoise and Hare (two-pointer) or use a visited set.",
        "io": [],
        "constraints": [],
        "note": "Floyd's Cycle Detection (Tortoise and Hare): use two pointers, slow (moves 1 step) and fast (moves 2 steps). If they meet, there's a cycle. If fast reaches end, no cycle. O(n) time, O(1) space.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft",
        "Bloomberg"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function hasCycle(head: ListNode | null): boolean {\n    if (!head || !head.next) {\n        return false;\n    }\n    \n    let slow: ListNode | null = head;\n    let fast: ListNode | null = head;\n    \n    while (fast && fast.next) {\n        slow = slow!.next;\n        fast = fast.next.next;\n        \n        if (slow === fast) {\n            return true;\n        }\n    }\n    \n    return false;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def hasCycle(head: Optional[ListNode]) -> bool:\n    if not head or not head.next:\n        return False\n    \n    slow = head\n    fast = head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        \n        if slow == fast:\n            return True\n    \n    return False"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean hasCycle(ListNode head) {\n    if (head == null || head.next == null) {\n        return false;\n    }\n    \n    ListNode slow = head;\n    ListNode fast = head;\n    \n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        \n        if (slow == fast) {\n            return true;\n        }\n    }\n    \n    return false;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool hasCycle(ListNode *head) {\n    if (!head || !head->next) {\n        return false;\n    }\n    \n    ListNode* slow = head;\n    ListNode* fast = head;\n    \n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        \n        if (slow == fast) {\n            return true;\n        }\n    }\n    \n    return false;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Floyd's Cycle Detection (Tortoise and Hare): use two pointers, slow (moves 1 step) and fast (moves 2 steps). If they meet, there's a cycle. If fast reaches end, no cycle. O(n) time, O(1) space.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=gBTe7lFR3vc",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/linked-list-cycle/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "merge-two-sorted-lists": {
    "id": "merge-two-sorted-lists",
    "name": "Merge Two Sorted Lists",
    "title": "Merge Two Sorted Lists",
    "category": "Linked List",
    "explanation": {
        "problemStatement": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.\n\nExample:\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]",
        "io": [],
        "constraints": [],
        "note": "Use dummy node to simplify edge cases. Compare values from both lists, attach smaller to result, advance that pointer. After loop, attach remaining list. Return dummy.next.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Microsoft"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function mergeTwoLists(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    const dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (l1 && l2) {\n        if (l1.val < l2.val) {\n            current.next = l1;\n            l1 = l1.next;\n        } else {\n            current.next = l2;\n            l2 = l2.next;\n        }\n        current = current.next;\n    }\n    \n    current.next = l1 || l2;\n    \n    return dummy.next;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def mergeTwoLists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n    dummy = ListNode(0)\n    current = dummy\n    \n    while l1 and l2:\n        if l1.val < l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n    \n    # Attach remaining nodes\n    current.next = l1 if l1 else l2\n    \n    return dummy.next"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0);\n    ListNode current = dummy;\n    \n    while (l1 != null && l2 != null) {\n        if (l1.val < l2.val) {\n            current.next = l1;\n            l1 = l1.next;\n        } else {\n            current.next = l2;\n            l2 = l2.next;\n        }\n        current = current.next;\n    }\n    \n    current.next = (l1 != null) ? l1 : l2;\n    \n    return dummy.next;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    \n    while (l1 && l2) {\n        if (l1->val < l2->val) {\n            current->next = l1;\n            l1 = l1->next;\n        } else {\n            current->next = l2;\n            l2 = l2->next;\n        }\n        current = current->next;\n    }\n    \n    current->next = l1 ? l1 : l2;\n    \n    return dummy->next;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use dummy node to simplify edge cases. Compare values from both lists, attach smaller to result, advance that pointer. After loop, attach remaining list. Return dummy.next.",
    "timeComplexity": "O(n + m)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=XIdigk956u0",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "merge-k-sorted-lists": {
    "id": "merge-k-sorted-lists",
    "name": "Merge K Sorted Lists",
    "title": "Merge K Sorted Lists",
    "category": "Linked List",
    "explanation": {
        "problemStatement": "You are given an array of k sorted linked-lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.\n\nExample:\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\n\nApproaches: use a min-heap (priority queue) or divide and conquer merging.",
        "io": [],
        "constraints": [],
        "note": "Use min-heap to efficiently find smallest among k lists. Add first node from each list to heap. Pop minimum, add to result, push its next node to heap. Repeat until heap empty. O(N log k) time where N = total nodes.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Google"
    ],
    "difficulty": "advance",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n    const heap: Array<ListNode> = [];\n    \n    // Min heap operations\n    const parent = (i: number) => Math.floor((i - 1) / 2);\n    const left = (i: number) => 2 * i + 1;\n    const right = (i: number) => 2 * i + 2;\n    \n    const swap = (i: number, j: number) => {\n        [heap[i], heap[j]] = [heap[j], heap[i]];\n    };\n    \n    const heapifyUp = (i: number) => {\n        while (i > 0 && heap[parent(i)].val > heap[i].val) {\n            swap(i, parent(i));\n            i = parent(i);\n        }\n    };\n    \n    const heapifyDown = (i: number) => {\n        let minIndex = i;\n        const l = left(i), r = right(i);\n        \n        if (l < heap.length && heap[l].val < heap[minIndex].val) minIndex = l;\n        if (r < heap.length && heap[r].val < heap[minIndex].val) minIndex = r;\n        \n        if (i !== minIndex) {\n            swap(i, minIndex);\n            heapifyDown(minIndex);\n        }\n    };\n    \n    const push = (node: ListNode) => {\n        heap.push(node);\n        heapifyUp(heap.length - 1);\n    };\n    \n    const pop = (): ListNode => {\n        const min = heap[0];\n        heap[0] = heap[heap.length - 1];\n        heap.pop();\n        if (heap.length > 0) heapifyDown(0);\n        return min;\n    };\n    \n    // Add first node from each list\n    for (const head of lists) {\n        if (head) push(head);\n    }\n    \n    const dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (heap.length > 0) {\n        const node = pop();\n        current.next = node;\n        current = current.next;\n        \n        if (node.next) push(node.next);\n    }\n    \n    return dummy.next;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "import heapq\n\ndef mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n    # Min heap: (value, index, node)\n    heap = []\n    \n    # Add first node from each list\n    for i, head in enumerate(lists):\n        if head:\n            heapq.heappush(heap, (head.val, i, head))\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        val, i, node = heapq.heappop(heap)\n        current.next = node\n        current = current.next\n        \n        # Add next node from same list\n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    \n    return dummy.next"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public ListNode mergeKLists(ListNode[] lists) {\n    PriorityQueue<ListNode> heap = new PriorityQueue<>((a, b) -> a.val - b.val);\n    \n    // Add first node from each list\n    for (ListNode head : lists) {\n        if (head != null) {\n            heap.offer(head);\n        }\n    }\n    \n    ListNode dummy = new ListNode(0);\n    ListNode current = dummy;\n    \n    while (!heap.isEmpty()) {\n        ListNode node = heap.poll();\n        current.next = node;\n        current = current.next;\n        \n        if (node.next != null) {\n            heap.offer(node.next);\n        }\n    }\n    \n    return dummy.next;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "ListNode* mergeKLists(vector<ListNode*>& lists) {\n    auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };\n    priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> heap(cmp);\n    \n    // Add first node from each list\n    for (ListNode* head : lists) {\n        if (head) {\n            heap.push(head);\n        }\n    }\n    \n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    \n    while (!heap.empty()) {\n        ListNode* node = heap.top();\n        heap.pop();\n        current->next = node;\n        current = current->next;\n        \n        if (node->next) {\n            heap.push(node->next);\n        }\n    }\n    \n    return dummy->next;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use min-heap to efficiently find smallest among k lists. Add first node from each list to heap. Pop minimum, add to result, push its next node to heap. Repeat until heap empty. O(N log k) time where N = total nodes.",
    "timeComplexity": "O(N log k)",
    "spaceComplexity": "O(k)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=XIdigk956u0",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "advance",
                "url": "https://leetcode.com/problems/merge-k-sorted-lists/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "remove-nth-node-from-end-of-list": {
    "id": "remove-nth-node-from-end-of-list",
    "name": "Remove Nth Node From End Of List",
    "title": "Remove Nth Node From End Of List",
    "category": "Linked List",
    "explanation": {
        "problemStatement": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\nExample:\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nOne-pass solution: dummy node + two pointers spaced n apart.",
        "io": [],
        "constraints": [],
        "note": "Two-pointer technique: use dummy node. Move fast pointer n+1 steps ahead, then move both pointers together. When fast reaches end, slow is before node to remove. One pass, O(1) space.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Microsoft"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\n    const dummy = new ListNode(0);\n    dummy.next = head;\n    let fast: ListNode | null = dummy;\n    let slow: ListNode | null = dummy;\n    \n    // Move fast n+1 steps ahead\n    for (let i = 0; i <= n; i++) {\n        if (fast) fast = fast.next;\n    }\n    \n    // Move both until fast reaches end\n    while (fast) {\n        fast = fast.next;\n        slow = slow!.next;\n    }\n    \n    // Remove nth node\n    slow!.next = slow!.next!.next;\n    \n    return dummy.next;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def removeNthFromEnd(head: Optional[ListNode], n: int) -> Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    fast = slow = dummy\n    \n    # Move fast n+1 steps ahead\n    for _ in range(n + 1):\n        if fast:\n            fast = fast.next\n    \n    # Move both until fast reaches end\n    while fast:\n        fast = fast.next\n        slow = slow.next\n    \n    # Remove nth node\n    slow.next = slow.next.next\n    \n    return dummy.next"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode fast = dummy;\n    ListNode slow = dummy;\n    \n    // Move fast n+1 steps ahead\n    for (int i = 0; i <= n; i++) {\n        fast = fast.next;\n    }\n    \n    // Move both until fast reaches end\n    while (fast != null) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    \n    // Remove nth node\n    slow.next = slow.next.next;\n    \n    return dummy.next;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "ListNode* removeNthFromEnd(ListNode* head, int n) {\n    ListNode* dummy = new ListNode(0);\n    dummy->next = head;\n    ListNode* fast = dummy;\n    ListNode* slow = dummy;\n    \n    // Move fast n+1 steps ahead\n    for (int i = 0; i <= n; i++) {\n        fast = fast->next;\n    }\n    \n    // Move both until fast reaches end\n    while (fast) {\n        fast = fast->next;\n        slow = slow->next;\n    }\n    \n    // Remove nth node\n    slow->next = slow->next->next;\n    \n    return dummy->next;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Two-pointer technique: use dummy node. Move fast pointer n+1 steps ahead, then move both pointers together. When fast reaches end, slow is before node to remove. One pass, O(1) space.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=XVuQxVej6y8",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "reorder-list": {
    "id": "reorder-list",
    "name": "Reorder List",
    "title": "Reorder List",
    "category": "Linked List",
    "explanation": {
        "problemStatement": "You are given the head of a singly linked-list. The list can be represented as: L0 → L1 → … → Ln-1 → Ln.\n\nReorder the list to: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …. You must do this in-place without altering the nodes' values.\n\nTypical approach: find middle with fast/slow, reverse second half, then merge the halves alternately.",
        "io": [],
        "constraints": [],
        "note": "Three steps: 1) Find middle using slow/fast pointers. 2) Reverse second half. 3) Merge alternately. L0→L1→...→Ln becomes L0→Ln→L1→Ln-1→.... O(n) time, O(1) space.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function reorderList(head: ListNode | null): void {\n    if (!head || !head.next) return;\n    \n    // Find middle\n    let slow = head, fast = head;\n    while (fast.next && fast.next.next) {\n        slow = slow.next!;\n        fast = fast.next.next;\n    }\n    \n    // Reverse second half\n    let second: ListNode | null = slow.next;\n    slow.next = null;\n    let prev: ListNode | null = null;\n    while (second) {\n        const temp = second.next;\n        second.next = prev;\n        prev = second;\n        second = temp;\n    }\n    \n    // Merge two halves\n    let first: ListNode | null = head;\n    second = prev;\n    while (second) {\n        const tmp1 = first!.next;\n        const tmp2 = second.next;\n        first!.next = second;\n        second.next = tmp1;\n        first = tmp1;\n        second = tmp2;\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def reorderList(head: Optional[ListNode]) -> None:\n    if not head or not head.next:\n        return\n    \n    # Find middle\n    slow = fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Reverse second half\n    second = slow.next\n    slow.next = None\n    prev = None\n    while second:\n        temp = second.next\n        second.next = prev\n        prev = second\n        second = temp\n    \n    # Merge two halves\n    first = head\n    second = prev\n    while second:\n        tmp1 = first.next\n        tmp2 = second.next\n        first.next = second\n        second.next = tmp1\n        first = tmp1\n        second = tmp2"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public void reorderList(ListNode head) {\n    if (head == null || head.next == null) return;\n    \n    // Find middle\n    ListNode slow = head, fast = head;\n    while (fast.next != null && fast.next.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    // Reverse second half\n    ListNode second = slow.next;\n    slow.next = null;\n    ListNode prev = null;\n    while (second != null) {\n        ListNode temp = second.next;\n        second.next = prev;\n        prev = second;\n        second = temp;\n    }\n    \n    // Merge two halves\n    ListNode first = head;\n    second = prev;\n    while (second != null) {\n        ListNode tmp1 = first.next;\n        ListNode tmp2 = second.next;\n        first.next = second;\n        second.next = tmp1;\n        first = tmp1;\n        second = tmp2;\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "void reorderList(ListNode* head) {\n    if (!head || !head->next) return;\n    \n    // Find middle\n    ListNode* slow = head;\n    ListNode* fast = head;\n    while (fast->next && fast->next->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    \n    // Reverse second half\n    ListNode* second = slow->next;\n    slow->next = nullptr;\n    ListNode* prev = nullptr;\n    while (second) {\n        ListNode* temp = second->next;\n        second->next = prev;\n        prev = second;\n        second = temp;\n    }\n    \n    // Merge two halves\n    ListNode* first = head;\n    second = prev;\n    while (second) {\n        ListNode* tmp1 = first->next;\n        ListNode* tmp2 = second->next;\n        first->next = second;\n        second->next = tmp1;\n        first = tmp1;\n        second = tmp2;\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Three steps: 1) Find middle using slow/fast pointers. 2) Reverse second half. 3) Merge alternately. L0→L1→...→Ln becomes L0→Ln→L1→Ln-1→.... O(n) time, O(1) space.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=S5bfdUTrKLM",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/reorder-list/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "set-matrix-zeroes": {
    "id": "set-matrix-zeroes",
    "name": "Set Matrix Zeroes",
    "title": "Set Matrix Zeroes",
    "category": "Matrix",
    "explanation": {
        "problemStatement": "Given an m × n integer matrix, if an element is 0, set its entire row and column to 0s. You must do it in place.\n\nExample:\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n\nApproach: use first row/column as markers or two boolean arrays; handle first row/col specially to avoid overwriting markers.",
        "io": [],
        "constraints": [],
        "note": "Use three pointers: prev (initially null), current (head), and next. Iterate through list: save next node, reverse current's pointer to prev, move prev and current forward. Return prev (new head).",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft",
        "Facebook"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function reverseList(head: ListNode | null): ListNode | null {\n    let prev: ListNode | null = null;\n    let current = head;\n    \n    while (current) {\n        const nextTemp = current.next;\n        current.next = prev;\n        prev = current;\n        current = nextTemp;\n    }\n    \n    return prev;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def reverseList(head: Optional[ListNode]) -> Optional[ListNode]:\n    prev = None\n    current = head\n    \n    while current:\n        # Save next node\n        next_temp = current.next\n        \n        # Reverse the link\n        current.next = prev\n        \n        # Move pointers forward\n        prev = current\n        current = next_temp\n    \n    return prev"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public ListNode reverseList(ListNode head) {\n    ListNode prev = null;\n    ListNode current = head;\n    \n    while (current != null) {\n        ListNode nextTemp = current.next;\n        current.next = prev;\n        prev = current;\n        current = nextTemp;\n    }\n    \n    return prev;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "ListNode* reverseList(ListNode* head) {\n    ListNode* prev = nullptr;\n    ListNode* current = head;\n    \n    while (current) {\n        ListNode* nextTemp = current->next;\n        current->next = prev;\n        prev = current;\n        current = nextTemp;\n    }\n    \n    return prev;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use three pointers: prev (initially null), current (head), and next. Iterate through list: save next node, reverse current's pointer to prev, move prev and current forward. Return prev (new head).",
    "timeComplexity": "O(m × n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=T41rL0L3Pnw",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/set-matrix-zeroes/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "spiral-matrix": {
    "id": "spiral-matrix",
    "name": "Spiral Matrix",
    "title": "Spiral Matrix",
    "category": "Matrix",
    "explanation": {
        "problemStatement": "Given an m × n matrix, return all elements of the matrix in spiral order.\n\nExample:\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nApproach: maintain top, bottom, left, right boundaries and traverse right → down → left → up while shrinking boundaries.",
        "io": [],
        "constraints": [],
        "note": "Track four boundaries: top, bottom, left, right. Traverse right→down→left→up in spiral, shrinking boundaries after each direction. Check boundaries before left/up to avoid duplicates. O(m×n) time, O(1) space.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft",
        "Facebook"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function spiralOrder(matrix: number[][]): number[] {\n    const result: number[] = [];\n    if (!matrix.length) return result;\n    \n    let top = 0, bottom = matrix.length - 1;\n    let left = 0, right = matrix[0].length - 1;\n    \n    while (top <= bottom && left <= right) {\n        for (let j = left; j <= right; j++) {\n            result.push(matrix[top][j]);\n        }\n        top++;\n        \n        for (let i = top; i <= bottom; i++) {\n            result.push(matrix[i][right]);\n        }\n        right--;\n        \n        if (top <= bottom) {\n            for (let j = right; j >= left; j--) {\n                result.push(matrix[bottom][j]);\n            }\n            bottom--;\n        }\n        \n        if (left <= right) {\n            for (let i = bottom; i >= top; i--) {\n                result.push(matrix[i][left]);\n            }\n            left++;\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def spiralOrder(matrix: List[List[int]]) -> List[int]:\n    result = []\n    if not matrix:\n        return result\n    \n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        # Right\n        for j in range(left, right + 1):\n            result.append(matrix[top][j])\n        top += 1\n        \n        # Down\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            # Left\n            for j in range(right, left - 1, -1):\n                result.append(matrix[bottom][j])\n            bottom -= 1\n        \n        if left <= right:\n            # Up\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> result = new ArrayList<>();\n    if (matrix.length == 0) return result;\n    \n    int top = 0, bottom = matrix.length - 1;\n    int left = 0, right = matrix[0].length - 1;\n    \n    while (top <= bottom && left <= right) {\n        for (int j = left; j <= right; j++) {\n            result.add(matrix[top][j]);\n        }\n        top++;\n        \n        for (int i = top; i <= bottom; i++) {\n            result.add(matrix[i][right]);\n        }\n        right--;\n        \n        if (top <= bottom) {\n            for (int j = right; j >= left; j--) {\n                result.add(matrix[bottom][j]);\n            }\n            bottom--;\n        }\n        \n        if (left <= right) {\n            for (int i = bottom; i >= top; i--) {\n                result.add(matrix[i][left]);\n            }\n            left++;\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\n    vector<int> result;\n    if (matrix.empty()) return result;\n    \n    int top = 0, bottom = matrix.size() - 1;\n    int left = 0, right = matrix[0].size() - 1;\n    \n    while (top <= bottom && left <= right) {\n        for (int j = left; j <= right; j++) {\n            result.push_back(matrix[top][j]);\n        }\n        top++;\n        \n        for (int i = top; i <= bottom; i++) {\n            result.push_back(matrix[i][right]);\n        }\n        right--;\n        \n        if (top <= bottom) {\n            for (int j = right; j >= left; j--) {\n                result.push_back(matrix[bottom][j]);\n            }\n            bottom--;\n        }\n        \n        if (left <= right) {\n            for (int i = bottom; i >= top; i--) {\n                result.push_back(matrix[i][left]);\n            }\n            left++;\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Track four boundaries: top, bottom, left, right. Traverse right→down→left→up in spiral, shrinking boundaries after each direction. Check boundaries before left/up to avoid duplicates. O(m×n) time, O(1) space.",
    "timeComplexity": "O(m × n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=BJnMZNwUk1M",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/spiral-matrix/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "rotate-image": {
    "id": "rotate-image",
    "name": "Rotate Image",
    "title": "Rotate Image",
    "category": "Matrix",
    "explanation": {
        "problemStatement": "You are given an n × n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You have to rotate the image in-place.\n\nExample:\nInput: [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\nNote: Do not allocate another 2D matrix. (source: https://leetcode.com/problems/rotate-image/)",
        "io": [],
        "constraints": [],
        "note": "Two steps for 90° clockwise rotation: 1) Transpose matrix (swap matrix[i][j] with matrix[j][i]). 2) Reverse each row. For counter-clockwise, reverse columns instead. O(n²) time, O(1) space.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft",
        "Apple"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function rotate(matrix: number[][]): void {\n    const n = matrix.length;\n    \n    // Transpose\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n        }\n    }\n    \n    // Reverse each row\n    for (let i = 0; i < n; i++) {\n        matrix[i].reverse();\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def rotate(matrix: List[List[int]]) -> None:\n    n = len(matrix)\n    \n    # Transpose matrix\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    \n    # Reverse each row\n    for i in range(n):\n        matrix[i].reverse()"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public void rotate(int[][] matrix) {\n    int n = matrix.length;\n    \n    // Transpose\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[j][i];\n            matrix[j][i] = temp;\n        }\n    }\n    \n    // Reverse each row\n    for (int i = 0; i < n; i++) {\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int temp = matrix[i][left];\n            matrix[i][left] = matrix[i][right];\n            matrix[i][right] = temp;\n            left++;\n            right--;\n        }\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "void rotate(vector<vector<int>>& matrix) {\n    int n = matrix.size();\n    \n    // Transpose\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            swap(matrix[i][j], matrix[j][i]);\n        }\n    }\n    \n    // Reverse each row\n    for (int i = 0; i < n; i++) {\n        reverse(matrix[i].begin(), matrix[i].end());\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Two steps for 90° clockwise rotation: 1) Transpose matrix (swap matrix[i][j] with matrix[j][i]). 2) Reverse each row. For counter-clockwise, reverse columns instead. O(n²) time, O(1) space.",
    "timeComplexity": "O(n²)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=fMSJSS7eO1w",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/rotate-image/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "word-search": {
    "id": "word-search",
    "name": "Word Search",
    "title": "Word Search",
    "category": "Matrix",
    "explanation": {
        "problemStatement": "Given an m × n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same cell may not be used more than once.\n\nExample:\nInput: board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCCED'\nOutput: true\n\n(source: https://leetcode.com/problems/word-search/)",
        "io": [],
        "constraints": [],
        "note": "Backtracking DFS. For each cell, if it matches word[0], start DFS. Mark visited cells, try 4 directions. If path found, return true. Backtrack by unmarking. O(m×n×4^L) worst case.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft",
        "Facebook"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function exist(board: string[][], word: string): boolean {\n    const m = board.length, n = board[0].length;\n    \n    function dfs(r: number, c: number, index: number): boolean {\n        if (index === word.length) return true;\n        \n        if (r < 0 || r >= m || c < 0 || c >= n ||\n            board[r][c] !== word[index]) {\n            return false;\n        }\n        \n        const temp = board[r][c];\n        board[r][c] = '#';\n        \n        const found = dfs(r+1, c, index+1) || dfs(r-1, c, index+1) ||\n                     dfs(r, c+1, index+1) || dfs(r, c-1, index+1);\n        \n        board[r][c] = temp;\n        return found;\n    }\n    \n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (dfs(i, j, 0)) return true;\n        }\n    }\n    \n    return false;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def exist(board: List[List[str]], word: str) -> bool:\n    m, n = len(board), len(board[0])\n    \n    def dfs(r, c, index):\n        if index == len(word):\n            return True\n        \n        if (r < 0 or r >= m or c < 0 or c >= n or \n            board[r][c] != word[index]):\n            return False\n        \n        # Mark as visited\n        temp = board[r][c]\n        board[r][c] = '#'\n        \n        # Try all 4 directions\n        found = (dfs(r+1, c, index+1) or dfs(r-1, c, index+1) or\n                 dfs(r, c+1, index+1) or dfs(r, c-1, index+1))\n        \n        # Backtrack\n        board[r][c] = temp\n        return found\n    \n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n    \n    return False"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean exist(char[][] board, String word) {\n    int m = board.length, n = board[0].length;\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, word, i, j, 0)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nprivate boolean dfs(char[][] board, String word, int r, int c, int index) {\n    if (index == word.length()) return true;\n    \n    if (r < 0 || r >= board.length || c < 0 || c >= board[0].length ||\n        board[r][c] != word.charAt(index)) {\n        return false;\n    }\n    \n    char temp = board[r][c];\n    board[r][c] = '#';\n    \n    boolean found = dfs(board, word, r+1, c, index+1) ||\n                    dfs(board, word, r-1, c, index+1) ||\n                    dfs(board, word, r, c+1, index+1) ||\n                    dfs(board, word, r, c-1, index+1);\n    \n    board[r][c] = temp;\n    return found;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool dfs(vector<vector<char>>& board, string& word, int r, int c, int index) {\n    if (index == word.length()) return true;\n    \n    if (r < 0 || r >= board.size() || c < 0 || c >= board[0].size() ||\n        board[r][c] != word[index]) {\n        return false;\n    }\n    \n    char temp = board[r][c];\n    board[r][c] = '#';\n    \n    bool found = dfs(board, word, r+1, c, index+1) ||\n                 dfs(board, word, r-1, c, index+1) ||\n                 dfs(board, word, r, c+1, index+1) ||\n                 dfs(board, word, r, c-1, index+1);\n    \n    board[r][c] = temp;\n    return found;\n}\n\nbool exist(vector<vector<char>>& board, string word) {\n    for (int i = 0; i < board.size(); i++) {\n        for (int j = 0; j < board[0].size(); j++) {\n            if (dfs(board, word, i, j, 0)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Backtracking DFS. For each cell, if it matches word[0], start DFS. Mark visited cells, try 4 directions. If path found, return true. Backtrack by unmarking. O(m×n×4^L) worst case.",
    "timeComplexity": "O(m × n × 4^L)",
    "spaceComplexity": "O(L)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=pfiQ_PS1g8E",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/word-search/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "longest-substring-without-repeating-characters": {
    "id": "longest-substring-without-repeating-characters",
    "name": "Longest Substring Without Repeating Characters",
    "title": "Longest Substring Without Repeating Characters",
    "category": "String",
    "explanation": {
        "problemStatement": "Given a string s, find the length of the longest substring in which no character appears more than once.\n\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with length 3.\n\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with length 1.\n\nConstraints: 0 <= s.length <= 5 * 10^4; s consists of English letters, digits, symbols and spaces.",
        "io": [],
        "constraints": [],
        "note": "Sliding window with hashmap. Track last seen index of each character. When duplicate found in current window, move left pointer past previous occurrence. Track maximum window size. O(n) time.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Bloomberg"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function lengthOfLongestSubstring(s: string): number {\n    const charIndex = new Map<string, number>();\n    let maxLength = 0;\n    let left = 0;\n    \n    for (let right = 0; right < s.length; right++) {\n        const c = s[right];\n        \n        if (charIndex.has(c) && charIndex.get(c)! >= left) {\n            left = charIndex.get(c)! + 1;\n        }\n        \n        charIndex.set(c, right);\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def lengthOfLongestSubstring(s: str) -> int:\n    char_index = {}\n    max_length = 0\n    left = 0\n    \n    for right in range(len(s)):\n        # If char seen and in current window\n        if s[right] in char_index and char_index[s[right]] >= left:\n            left = char_index[s[right]] + 1\n        \n        char_index[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int lengthOfLongestSubstring(String s) {\n    Map<Character, Integer> charIndex = new HashMap<>();\n    int maxLength = 0;\n    int left = 0;\n    \n    for (int right = 0; right < s.length(); right++) {\n        char c = s.charAt(right);\n        \n        if (charIndex.containsKey(c) && charIndex.get(c) >= left) {\n            left = charIndex.get(c) + 1;\n        }\n        \n        charIndex.put(c, right);\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int lengthOfLongestSubstring(string s) {\n    unordered_map<char, int> charIndex;\n    int maxLength = 0;\n    int left = 0;\n    \n    for (int right = 0; right < s.length(); right++) {\n        char c = s[right];\n        \n        if (charIndex.find(c) != charIndex.end() && charIndex[c] >= left) {\n            left = charIndex[c] + 1;\n        }\n        \n        charIndex[c] = right;\n        maxLength = max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Sliding window with hashmap. Track last seen index of each character. When duplicate found in current window, move left pointer past previous occurrence. Track maximum window size. O(n) time.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(min(m,n))",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=wiGpQwVHdE0",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "longest-repeating-character-replacement": {
    "id": "longest-repeating-character-replacement",
    "name": "Longest Repeating Character Replacement",
    "title": "Longest Repeating Character Replacement",
    "category": "String",
    "explanation": {
        "problemStatement": "You are given a string s and an integer k. You may change at most k characters in s; each change converts one character to any other uppercase English letter. Return the length of the longest substring containing the same letter you can obtain after performing at most k changes.\n\nExample 1:\nInput: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with 'B's or vice versa to obtain \"BBBB\" or \"AAAA\" of length 4.\n\nExample 2:\nInput: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the substring \"ABBA\" to get \"BBBB\".\n\nConstraints: 1 <= s.length <= 10^5; s consists of uppercase English letters; 0 <= k <= s.length.",
        "io": [],
        "constraints": [],
        "note": "Sliding window. Track count of most frequent char in window. If (window size - max frequency) > k, shrink window. Window is valid if we can replace remaining chars within k changes. O(n) time.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Google"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function characterReplacement(s: string, k: number): number {\n    const count = new Array(26).fill(0);\n    let maxLength = 0;\n    let maxCount = 0;\n    let left = 0;\n    \n    for (let right = 0; right < s.length; right++) {\n        count[s.charCodeAt(right) - 65]++;\n        maxCount = Math.max(maxCount, count[s.charCodeAt(right) - 65]);\n        \n        while ((right - left + 1) - maxCount > k) {\n            count[s.charCodeAt(left) - 65]--;\n            left++;\n        }\n        \n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def characterReplacement(s: str, k: int) -> int:\n    count = {}\n    max_length = 0\n    max_count = 0\n    left = 0\n    \n    for right in range(len(s)):\n        count[s[right]] = count.get(s[right], 0) + 1\n        max_count = max(max_count, count[s[right]])\n        \n        # If window invalid, shrink from left\n        while (right - left + 1) - max_count > k:\n            count[s[left]] -= 1\n            left += 1\n        \n        max_length = max(max_length, right - left + 1)\n    \n    return max_length"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int characterReplacement(String s, int k) {\n    int[] count = new int[26];\n    int maxLength = 0;\n    int maxCount = 0;\n    int left = 0;\n    \n    for (int right = 0; right < s.length(); right++) {\n        count[s.charAt(right) - 'A']++;\n        maxCount = Math.max(maxCount, count[s.charAt(right) - 'A']);\n        \n        while ((right - left + 1) - maxCount > k) {\n            count[s.charAt(left) - 'A']--;\n            left++;\n        }\n        \n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int characterReplacement(string s, int k) {\n    vector<int> count(26, 0);\n    int maxLength = 0;\n    int maxCount = 0;\n    int left = 0;\n    \n    for (int right = 0; right < s.length(); right++) {\n        count[s[right] - 'A']++;\n        maxCount = max(maxCount, count[s[right] - 'A']);\n        \n        while ((right - left + 1) - maxCount > k) {\n            count[s[left] - 'A']--;\n            left++;\n        }\n        \n        maxLength = max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Sliding window. Track count of most frequent char in window. If (window size - max frequency) > k, shrink window. Window is valid if we can replace remaining chars within k changes. O(n) time.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=gqXU1UyA8pk",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/longest-repeating-character-replacement/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "minimum-window-substring": {
    "id": "minimum-window-substring",
    "name": "Minimum Window Substring",
    "title": "Minimum Window Substring",
    "category": "String",
    "explanation": {
        "problemStatement": "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n\nExample 1:\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\n\nExample 2:\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\n\nConstraints: 1 <= s.length, t.length <= 10^5; s and t consist of ASCII characters.",
        "io": [],
        "constraints": [],
        "note": "Sliding window with two hashmaps. Expand right to include chars from t. When window contains all required chars, shrink from left while valid. Track minimum window. O(m+n) time where m,n are lengths of s,t.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon",
        "LinkedIn"
    ],
    "difficulty": "advance",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function minWindow(s: string, t: string): string {\n    if (!s || !t) return \"\";\n    \n    const need = new Map<string, number>();\n    for (const c of t) {\n        need.set(c, (need.get(c) || 0) + 1);\n    }\n    \n    const required = need.size;\n    let formed = 0;\n    const window = new Map<string, number>();\n    \n    let left = 0;\n    let minLen = Infinity;\n    let minLeft = 0;\n    \n    for (let right = 0; right < s.length; right++) {\n        const c = s[right];\n        window.set(c, (window.get(c) || 0) + 1);\n        \n        if (need.has(c) && window.get(c) === need.get(c)) {\n            formed++;\n        }\n        \n        while (left <= right && formed === required) {\n            if (right - left + 1 < minLen) {\n                minLen = right - left + 1;\n                minLeft = left;\n            }\n            \n            const leftChar = s[left];\n            window.set(leftChar, window.get(leftChar)! - 1);\n            if (need.has(leftChar) && window.get(leftChar)! < need.get(leftChar)!) {\n                formed--;\n            }\n            left++;\n        }\n    }\n    \n    return minLen === Infinity ? \"\" : s.substring(minLeft, minLeft + minLen);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def minWindow(s: str, t: str) -> str:\n    if not s or not t:\n        return \"\"\n    \n    need = {}\n    for c in t:\n        need[c] = need.get(c, 0) + 1\n    \n    required = len(need)\n    formed = 0\n    window = {}\n    \n    left = 0\n    min_len = float('inf')\n    min_left = 0\n    \n    for right in range(len(s)):\n        char = s[right]\n        window[char] = window.get(char, 0) + 1\n        \n        if char in need and window[char] == need[char]:\n            formed += 1\n        \n        # Shrink window\n        while left <= right and formed == required:\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_left = left\n            \n            char = s[left]\n            window[char] -= 1\n            if char in need and window[char] < need[char]:\n                formed -= 1\n            left += 1\n    \n    return \"\" if min_len == float('inf') else s[min_left:min_left + min_len]"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public String minWindow(String s, String t) {\n    if (s.length() == 0 || t.length() == 0) return \"\";\n    \n    Map<Character, Integer> need = new HashMap<>();\n    for (char c : t.toCharArray()) {\n        need.put(c, need.getOrDefault(c, 0) + 1);\n    }\n    \n    int required = need.size();\n    int formed = 0;\n    Map<Character, Integer> window = new HashMap<>();\n    \n    int left = 0;\n    int minLen = Integer.MAX_VALUE;\n    int minLeft = 0;\n    \n    for (int right = 0; right < s.length(); right++) {\n        char c = s.charAt(right);\n        window.put(c, window.getOrDefault(c, 0) + 1);\n        \n        if (need.containsKey(c) && window.get(c).intValue() == need.get(c).intValue()) {\n            formed++;\n        }\n        \n        while (left <= right && formed == required) {\n            if (right - left + 1 < minLen) {\n                minLen = right - left + 1;\n                minLeft = left;\n            }\n            \n            char leftChar = s.charAt(left);\n            window.put(leftChar, window.get(leftChar) - 1);\n            if (need.containsKey(leftChar) && window.get(leftChar) < need.get(leftChar)) {\n                formed--;\n            }\n            left++;\n        }\n    }\n    \n    return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minLeft, minLeft + minLen);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "string minWindow(string s, string t) {\n    if (s.empty() || t.empty()) return \"\";\n    \n    unordered_map<char, int> need, window;\n    for (char c : t) {\n        need[c]++;\n    }\n    \n    int required = need.size();\n    int formed = 0;\n    \n    int left = 0;\n    int minLen = INT_MAX;\n    int minLeft = 0;\n    \n    for (int right = 0; right < s.length(); right++) {\n        char c = s[right];\n        window[c]++;\n        \n        if (need.find(c) != need.end() && window[c] == need[c]) {\n            formed++;\n        }\n        \n        while (left <= right && formed == required) {\n            if (right - left + 1 < minLen) {\n                minLen = right - left + 1;\n                minLeft = left;\n            }\n            \n            char leftChar = s[left];\n            window[leftChar]--;\n            if (need.find(leftChar) != need.end() && window[leftChar] < need[leftChar]) {\n                formed--;\n            }\n            left++;\n        }\n    }\n    \n    return minLen == INT_MAX ? \"\" : s.substr(minLeft, minLen);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Sliding window with two hashmaps. Expand right to include chars from t. When window contains all required chars, shrink from left while valid. Track minimum window. O(m+n) time where m,n are lengths of s,t.",
    "timeComplexity": "O(m + n)",
    "spaceComplexity": "O(m + n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=jSto0O4AJbM",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "advance",
                "url": "https://leetcode.com/problems/minimum-window-substring/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "valid-anagram": {
    "id": "valid-anagram",
    "name": "Valid Anagram",
    "title": "Valid Anagram",
    "category": "String",
    "explanation": {
        "problemStatement": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An anagram means the two strings contain the same characters with the same frequencies.\n\nExample 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nConstraints: 1 <= s.length, t.length <= 5 * 10^4; s and t consist of lowercase English letters.",
        "io": [],
        "constraints": [],
        "note": "Count character frequencies. For lowercase English letters, use array of size 26. Increment for s, decrement for t. If any goes negative or lengths differ, not anagram. O(n) time, O(1) space.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Bloomberg"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function isAnagram(s: string, t: string): boolean {\n    if (s.length !== t.length) {\n        return false;\n    }\n    \n    const count = new Array(26).fill(0);\n    \n    for (const c of s) {\n        count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    \n    for (const c of t) {\n        count[c.charCodeAt(0) - 'a'.charCodeAt(0)]--;\n        if (count[c.charCodeAt(0) - 'a'.charCodeAt(0)] < 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def isAnagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    count = {}\n    \n    for char in s:\n        count[char] = count.get(char, 0) + 1\n    \n    for char in t:\n        if char not in count:\n            return False\n        count[char] -= 1\n        if count[char] < 0:\n            return False\n    \n    return True"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    \n    int[] count = new int[26];\n    \n    for (char c : s.toCharArray()) {\n        count[c - 'a']++;\n    }\n    \n    for (char c : t.toCharArray()) {\n        count[c - 'a']--;\n        if (count[c - 'a'] < 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool isAnagram(string s, string t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    \n    vector<int> count(26, 0);\n    \n    for (char c : s) {\n        count[c - 'a']++;\n    }\n    \n    for (char c : t) {\n        count[c - 'a']--;\n        if (count[c - 'a'] < 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Count character frequencies. For lowercase English letters, use array of size 26. Increment for s, decrement for t. If any goes negative or lengths differ, not anagram. O(n) time, O(1) space.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=9UtInBqnCgA",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/valid-anagram/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "group-anagrams": {
    "id": "group-anagrams",
    "name": "Group Anagrams",
    "title": "Group Anagrams",
    "category": "String",
    "explanation": {
        "problemStatement": "Given an array of strings strs, group the anagrams together. You may return the answer in any order.\n\nExample 1:\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]\n\nConstraints: 1 <= strs.length <= 10^4; 0 <= strs[i].length <= 100; strs[i] consists of lowercase English letters. The sum of all strs[i].length is ≤ 10^5.",
        "io": [],
        "constraints": [],
        "note": "Use sorted string as key in hashmap. All anagrams have same sorted form. Group strings with same key. O(n × k log k) where n = number of strings, k = max length. Alternative: use character count array as key for O(n × k).",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Bloomberg"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function groupAnagrams(strs: string[]): string[][] {\n    const anagrams = new Map<string, string[]>();\n    \n    for (const s of strs) {\n        const key = s.split('').sort().join('');\n        \n        if (!anagrams.has(key)) {\n            anagrams.set(key, []);\n        }\n        anagrams.get(key)!.push(s);\n    }\n    \n    return Array.from(anagrams.values());\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def groupAnagrams(strs: List[str]) -> List[List[str]]:\n    anagrams = {}\n    \n    for s in strs:\n        # Sort string as key\n        key = ''.join(sorted(s))\n        \n        if key not in anagrams:\n            anagrams[key] = []\n        anagrams[key].append(s)\n    \n    return list(anagrams.values())"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public List<List<String>> groupAnagrams(String[] strs) {\n    Map<String, List<String>> anagrams = new HashMap<>();\n    \n    for (String s : strs) {\n        char[] chars = s.toCharArray();\n        Arrays.sort(chars);\n        String key = new String(chars);\n        \n        anagrams.putIfAbsent(key, new ArrayList<>());\n        anagrams.get(key).add(s);\n    }\n    \n    return new ArrayList<>(anagrams.values());\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "vector<vector<string>> groupAnagrams(vector<string>& strs) {\n    unordered_map<string, vector<string>> anagrams;\n    \n    for (const string& s : strs) {\n        string key = s;\n        sort(key.begin(), key.end());\n        anagrams[key].push_back(s);\n    }\n    \n    vector<vector<string>> result;\n    for (auto& [key, group] : anagrams) {\n        result.push_back(group);\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use sorted string as key in hashmap. All anagrams have same sorted form. Group strings with same key. O(n × k log k) where n = number of strings, k = max length. Alternative: use character count array as key for O(n × k).",
    "timeComplexity": "O(n × k log k)",
    "spaceComplexity": "O(n × k)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=vzdNOK2oB2E&t=1s",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/group-anagrams/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "valid-parentheses": {
    "id": "valid-parentheses",
    "name": "Valid Parentheses",
    "title": "Valid Parentheses",
    "category": "String",
    "explanation": {
        "problemStatement": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: (1) Open brackets are closed by the same type of brackets, and (2) Open brackets are closed in the correct order.\n\nExample 1:\nInput: s = \"()\"\nOutput: true\n\nExample 2:\nInput: s = \"([)]\"\nOutput: false\n\nConstraints: 1 <= s.length <= 10^4; s consists only of the characters '(', ')', '{', '}', '[' and ']'.",
        "io": [],
        "constraints": [],
        "note": "Use stack. Push opening brackets. For closing brackets, check if stack top matches corresponding opening bracket. Pop if match, return false if not. At end, stack should be empty. O(n) time, O(n) space.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Bloomberg"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function isValid(s: string): boolean {\n    const stack: string[] = [];\n    const mapping: { [key: string]: string } = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    };\n    \n    for (const char of s) {\n        if (char in mapping) {\n            if (!stack.length || stack.pop() !== mapping[char]) {\n                return false;\n            }\n        } else {\n            stack.push(char);\n        }\n    }\n    \n    return stack.length === 0;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            # Closing bracket\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n        else:\n            # Opening bracket\n            stack.append(char)\n    \n    return len(stack) == 0"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n    Map<Character, Character> mapping = new HashMap<>();\n    mapping.put(')', '(');\n    mapping.put('}', '{');\n    mapping.put(']', '[');\n    \n    for (char c : s.toCharArray()) {\n        if (mapping.containsKey(c)) {\n            if (stack.isEmpty() || stack.pop() != mapping.get(c)) {\n                return false;\n            }\n        } else {\n            stack.push(c);\n        }\n    }\n    \n    return stack.isEmpty();\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool isValid(string s) {\n    stack<char> st;\n    unordered_map<char, char> mapping = {\n        {')', '('}, {'}', '{'}, {']', '['}\n    };\n    \n    for (char c : s) {\n        if (mapping.find(c) != mapping.end()) {\n            if (st.empty() || st.top() != mapping[c]) {\n                return false;\n            }\n            st.pop();\n        } else {\n            st.push(c);\n        }\n    }\n    \n    return st.empty();\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use stack. Push opening brackets. For closing brackets, check if stack top matches corresponding opening bracket. Pop if match, return false if not. At end, stack should be empty. O(n) time, O(n) space.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=WTzjTskDFMg",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/valid-parentheses/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "valid-palindrome": {
    "id": "valid-palindrome",
    "name": "Valid Palindrome",
    "title": "Valid Palindrome",
    "category": "String",
    "explanation": {
        "problemStatement": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Given a string s, return true if it is a palindrome, or false otherwise.\n\nExample 1:\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\n\nExample 2:\nInput: s = \"race a car\"\nOutput: false\n\nConstraints: 1 <= s.length <= 2 * 10^5; s consists of printable ASCII characters.",
        "io": [],
        "constraints": [],
        "note": "Two pointers from both ends. Skip non-alphanumeric chars. Compare lowercase versions. Move pointers inward. If any mismatch, not palindrome. O(n) time, O(1) space.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon",
        "Microsoft"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function isPalindrome(s: string): boolean {\n    let left = 0, right = s.length - 1;\n    \n    while (left < right) {\n        while (left < right && !isAlphanumeric(s[left])) {\n            left++;\n        }\n        while (left < right && !isAlphanumeric(s[right])) {\n            right--;\n        }\n        \n        if (s[left].toLowerCase() !== s[right].toLowerCase()) {\n            return false;\n        }\n        \n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nfunction isAlphanumeric(c: string): boolean {\n    return /^[a-zA-Z0-9]$/.test(c);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def isPalindrome(s: str) -> bool:\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # Skip non-alphanumeric\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        # Compare\n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean isPalindrome(String s) {\n    int left = 0, right = s.length() - 1;\n    \n    while (left < right) {\n        while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\n            left++;\n        }\n        while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\n            right--;\n        }\n        \n        if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {\n            return false;\n        }\n        \n        left++;\n        right--;\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool isPalindrome(string s) {\n    int left = 0, right = s.length() - 1;\n    \n    while (left < right) {\n        while (left < right && !isalnum(s[left])) {\n            left++;\n        }\n        while (left < right && !isalnum(s[right])) {\n            right--;\n        }\n        \n        if (tolower(s[left]) != tolower(s[right])) {\n            return false;\n        }\n        \n        left++;\n        right--;\n    }\n    \n    return true;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Two pointers from both ends. Skip non-alphanumeric chars. Compare lowercase versions. Move pointers inward. If any mismatch, not palindrome. O(n) time, O(1) space.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=jJXJ16kPFWg&t=25s",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/valid-palindrome/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "longest-palindromic-substring": {
    "id": "longest-palindromic-substring",
    "name": "Longest Palindromic Substring",
    "title": "Longest Palindromic Substring",
    "category": "String",
    "explanation": {
        "problemStatement": "Given a string s, return the longest palindromic substring in s.\n\nExample 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\n\nExample 2:\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\nConstraints: 1 <= s.length <= 1000; s consists of only ASCII characters.",
        "io": [],
        "constraints": [],
        "note": "Expand around center approach. For each position, try both odd (single center) and even (two centers) length palindromes. Expand outward while chars match. Track longest. O(n²) time, O(1) space.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Microsoft",
        "Facebook"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function longestPalindrome(s: string): string {\n    if (!s) return \"\";\n    \n    function expandAroundCenter(left: number, right: number): number {\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n    \n    let start = 0, maxLen = 0;\n    \n    for (let i = 0; i < s.length; i++) {\n        const len1 = expandAroundCenter(i, i);\n        const len2 = expandAroundCenter(i, i + 1);\n        const len = Math.max(len1, len2);\n        \n        if (len > maxLen) {\n            maxLen = len;\n            start = i - Math.floor((len - 1) / 2);\n        }\n    }\n    \n    return s.substring(start, start + maxLen);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def longestPalindrome(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    start = 0\n    max_len = 0\n    \n    for i in range(len(s)):\n        # Odd length palindromes\n        len1 = expand_around_center(i, i)\n        # Even length palindromes\n        len2 = expand_around_center(i, i + 1)\n        \n        length = max(len1, len2)\n        \n        if length > max_len:\n            max_len = length\n            start = i - (length - 1) // 2\n    \n    return s[start:start + max_len]"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public String longestPalindrome(String s) {\n    if (s == null || s.length() == 0) return \"\";\n    \n    int start = 0, maxLen = 0;\n    \n    for (int i = 0; i < s.length(); i++) {\n        int len1 = expandAroundCenter(s, i, i);\n        int len2 = expandAroundCenter(s, i, i + 1);\n        int len = Math.max(len1, len2);\n        \n        if (len > maxLen) {\n            maxLen = len;\n            start = i - (len - 1) / 2;\n        }\n    }\n    \n    return s.substring(start, start + maxLen);\n}\n\nprivate int expandAroundCenter(String s, int left, int right) {\n    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n        left--;\n        right++;\n    }\n    return right - left - 1;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int expandAroundCenter(string& s, int left, int right) {\n    while (left >= 0 && right < s.length() && s[left] == s[right]) {\n        left--;\n        right++;\n    }\n    return right - left - 1;\n}\n\nstring longestPalindrome(string s) {\n    if (s.empty()) return \"\";\n    \n    int start = 0, maxLen = 0;\n    \n    for (int i = 0; i < s.length(); i++) {\n        int len1 = expandAroundCenter(s, i, i);\n        int len2 = expandAroundCenter(s, i, i + 1);\n        int len = max(len1, len2);\n        \n        if (len > maxLen) {\n            maxLen = len;\n            start = i - (len - 1) / 2;\n        }\n    }\n    \n    return s.substr(start, maxLen);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Expand around center approach. For each position, try both odd (single center) and even (two centers) length palindromes. Expand outward while chars match. Track longest. O(n²) time, O(1) space.",
    "timeComplexity": "O(n²)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=XYQecbcd6_c",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "palindromic-substrings": {
    "id": "palindromic-substrings",
    "name": "Palindromic Substrings",
    "title": "Palindromic Substrings",
    "category": "String",
    "explanation": {
        "problemStatement": "Given a string s, return the number of palindromic substrings in it. A substring is palindromic if it reads the same backward as forward.\n\nExample 1:\nInput: s = \"abc\"\nOutput: 3\nExplanation: Three palindromic substrings: \"a\", \"b\", \"c\".\n\nExample 2:\nInput: s = \"aaa\"\nOutput: 6\nExplanation: Six palindromic substrings: \"a\",\"a\",\"a\",\"aa\",\"aa\",\"aaa\".\n\nConstraints: 1 <= s.length <= 1000; s consists of lowercase English letters.",
        "io": [],
        "constraints": [],
        "note": "Similar to longest palindromic substring but count all instead of tracking max. For each center, expand and count valid palindromes. O(n²) time, O(1) space.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function countSubstrings(s: string): number {\n    let count = 0;\n    \n    function expandAroundCenter(left: number, right: number): void {\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            count++;\n            left--;\n            right++;\n        }\n    }\n    \n    for (let i = 0; i < s.length; i++) {\n        expandAroundCenter(i, i);\n        expandAroundCenter(i, i + 1);\n    }\n    \n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def countSubstrings(s: str) -> int:\n    count = 0\n    \n    def expand_around_center(left, right):\n        nonlocal count\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    \n    for i in range(len(s)):\n        # Odd length\n        expand_around_center(i, i)\n        # Even length\n        expand_around_center(i, i + 1)\n    \n    return count"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int countSubstrings(String s) {\n    int count = 0;\n    \n    for (int i = 0; i < s.length(); i++) {\n        count += expandAroundCenter(s, i, i);\n        count += expandAroundCenter(s, i, i + 1);\n    }\n    \n    return count;\n}\n\nprivate int expandAroundCenter(String s, int left, int right) {\n    int count = 0;\n    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n        count++;\n        left--;\n        right++;\n    }\n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int expandAroundCenter(string& s, int left, int right) {\n    int count = 0;\n    while (left >= 0 && right < s.length() && s[left] == s[right]) {\n        count++;\n        left--;\n        right++;\n    }\n    return count;\n}\n\nint countSubstrings(string s) {\n    int count = 0;\n    \n    for (int i = 0; i < s.length(); i++) {\n        count += expandAroundCenter(s, i, i);\n        count += expandAroundCenter(s, i, i + 1);\n    }\n    \n    return count;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Similar to longest palindromic substring but count all instead of tracking max. For each center, expand and count valid palindromes. O(n²) time, O(1) space.",
    "timeComplexity": "O(n²)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=4RACzI5-du8",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/palindromic-substrings/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "encode-and-decode-strings": {
    "id": "encode-and-decode-strings",
    "name": "Encode and Decode Strings (LeetCode Premium)",
    "title": "Encode and Decode Strings (LeetCode Premium)",
    "category": "String",
    "explanation": {
        "problemStatement": "Design an algorithm to encode a list of strings to a single string. The encoded string is sent over the network and should be decoded back to the original list of strings.\n\nExample:\nInput: [\"lint\",\"code\",\"love\",\"you\"]\nOutput (one possible encoding): \"4#lint4#code4#love3#you\"\n\nConstraints: 1 <= total length of all strings <= 10^5; Strings may contain any characters.",
        "io": [],
        "constraints": [],
        "note": "Length-prefixed encoding: for each string, prepend length + delimiter (#). To decode: read length, skip delimiter, extract that many chars. Handles any characters including delimiters. O(n) time for both.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Google",
        "Facebook"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function encode(strs: string[]): string {\n    let result = \"\";\n    for (const s of strs) {\n        result += s.length + \"#\" + s;\n    }\n    return result;\n}\n\nfunction decode(s: string): string[] {\n    const result: string[] = [];\n    let i = 0;\n    \n    while (i < s.length) {\n        let j = i;\n        while (s[j] !== '#') {\n            j++;\n        }\n        \n        const length = parseInt(s.substring(i, j));\n        result.push(s.substring(j + 1, j + 1 + length));\n        i = j + 1 + length;\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def encode(strs: List[str]) -> str:\n    result = \"\"\n    for s in strs:\n        result += str(len(s)) + \"#\" + s\n    return result\n\ndef decode(s: str) -> List[str]:\n    result = []\n    i = 0\n    \n    while i < len(s):\n        # Find delimiter\n        j = i\n        while s[j] != '#':\n            j += 1\n        \n        # Get length\n        length = int(s[i:j])\n        \n        # Extract string\n        result.append(s[j+1:j+1+length])\n        i = j + 1 + length\n    \n    return result"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public String encode(List<String> strs) {\n    StringBuilder result = new StringBuilder();\n    for (String s : strs) {\n        result.append(s.length()).append(\"#\").append(s);\n    }\n    return result.toString();\n}\n\npublic List<String> decode(String s) {\n    List<String> result = new ArrayList<>();\n    int i = 0;\n    \n    while (i < s.length()) {\n        int j = i;\n        while (s.charAt(j) != '#') {\n            j++;\n        }\n        \n        int length = Integer.parseInt(s.substring(i, j));\n        result.add(s.substring(j + 1, j + 1 + length));\n        i = j + 1 + length;\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "string encode(vector<string>& strs) {\n    string result;\n    for (const string& s : strs) {\n        result += to_string(s.length()) + \"#\" + s;\n    }\n    return result;\n}\n\nvector<string> decode(string s) {\n    vector<string> result;\n    int i = 0;\n    \n    while (i < s.length()) {\n        int j = i;\n        while (s[j] != '#') {\n            j++;\n        }\n        \n        int length = stoi(s.substr(i, j - i));\n        result.push_back(s.substr(j + 1, length));\n        i = j + 1 + length;\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Length-prefixed encoding: for each string, prepend length + delimiter (#). To decode: read length, skip delimiter, extract that many chars. Handles any characters including delimiters. O(n) time for both.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=B1k_sxOSgv8",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/encode-and-decode-strings/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "same-tree": {
    "id": "same-tree",
    "name": "Same Tree",
    "title": "Same Tree",
    "category": "Tree",
    "explanation": {
        "problemStatement": "Given the roots of two binary trees p and q, write a function to check if they are the same tree. Two binary trees are the same if they are structurally identical and the nodes have the same values.\n\nExample 1:\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nExample 2:\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\nConstraints: The number of nodes in both trees is in the range [0, 100]; -10^4 <= Node.val <= 10^4.",
        "io": [],
        "constraints": [],
        "note": "Use DFS recursion to compare trees node by node. Check: both null (same), one null (different), values different (different), then recurse on left and right subtrees.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Bloomberg"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    // Both empty\n    if (!p && !q) {\n        return true;\n    }\n    \n    // One empty, one not\n    if (!p || !q) {\n        return false;\n    }\n    \n    // Values different\n    if (p.val !== q.val) {\n        return false;\n    }\n    \n    // Recursively check left and right subtrees\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def isSameTree(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n    # Both empty\n    if not p and not q:\n        return True\n    \n    # One empty, one not\n    if not p or not q:\n        return False\n    \n    # Values different\n    if p.val != q.val:\n        return False\n    \n    # Recursively check left and right subtrees\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean isSameTree(TreeNode p, TreeNode q) {\n    // Both empty\n    if (p == null && q == null) {\n        return true;\n    }\n    \n    // One empty, one not\n    if (p == null || q == null) {\n        return false;\n    }\n    \n    // Values different\n    if (p.val != q.val) {\n        return false;\n    }\n    \n    // Recursively check left and right subtrees\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool isSameTree(TreeNode* p, TreeNode* q) {\n    // Both empty\n    if (!p && !q) {\n        return true;\n    }\n    \n    // One empty, one not\n    if (!p || !q) {\n        return false;\n    }\n    \n    // Values different\n    if (p->val != q->val) {\n        return false;\n    }\n    \n    // Recursively check left and right subtrees\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use DFS recursion to compare trees node by node. Check: both null (same), one null (different), values different (different), then recurse on left and right subtrees.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=vRbbcKXCxOw",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/same-tree/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "invert-binary-tree": {
    "id": "invert-binary-tree",
    "name": "Invert/Flip Binary Tree",
    "title": "Invert/Flip Binary Tree",
    "category": "Tree",
    "explanation": {
        "problemStatement": "Given the root of a binary tree, invert the tree and return its root.\n\nExample 1:\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n\nConstraints: The number of nodes in the tree is in the range [0, 100]; -100 <= Node.val <= 100.",
        "io": [],
        "constraints": [],
        "note": "For each node, swap its left and right children, then recursively invert the left and right subtrees. Simple DFS approach.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Google",
        "Amazon",
        "Bloomberg"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function invertTree(root: TreeNode | null): TreeNode | null {\n    if (!root) {\n        return null;\n    }\n    \n    // Swap left and right children\n    [root.left, root.right] = [root.right, root.left];\n    \n    // Recursively invert subtrees\n    invertTree(root.left);\n    invertTree(root.right);\n    \n    return root;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def invertTree(root: Optional[TreeNode]) -> Optional[TreeNode]:\n    if not root:\n        return None\n    \n    # Swap left and right children\n    root.left, root.right = root.right, root.left\n    \n    # Recursively invert subtrees\n    invertTree(root.left)\n    invertTree(root.right)\n    \n    return root"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public TreeNode invertTree(TreeNode root) {\n    if (root == null) {\n        return null;\n    }\n    \n    // Swap left and right children\n    TreeNode temp = root.left;\n    root.left = root.right;\n    root.right = temp;\n    \n    // Recursively invert subtrees\n    invertTree(root.left);\n    invertTree(root.right);\n    \n    return root;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "TreeNode* invertTree(TreeNode* root) {\n    if (!root) {\n        return nullptr;\n    }\n    \n    // Swap left and right children\n    TreeNode* temp = root->left;\n    root->left = root->right;\n    root->right = temp;\n    \n    // Recursively invert subtrees\n    invertTree(root->left);\n    invertTree(root->right);\n    \n    return root;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "For each node, swap its left and right children, then recursively invert the left and right subtrees. Simple DFS approach.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=OnSn2XEQ4MY",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problems/invert-binary-tree/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "binary-tree-maximum-path-sum": {
    "id": "binary-tree-maximum-path-sum",
    "name": "Binary Tree Maximum Path Sum",
    "title": "Binary Tree Maximum Path Sum",
    "category": "Tree",
    "explanation": {
        "problemStatement": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node may appear at most once in the sequence. Given the root of a binary tree, return the maximum path sum of any non-empty path.\n\nExample 1:\nInput: root = [1,2,3]\nOutput: 6\n\nExample 2:\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\n\nConstraints: The number of nodes in the tree is in the range [1, 3 * 10^4]; -1000 <= Node.val <= 1000.",
        "io": [],
        "constraints": [],
        "note": "For each node, calculate max path sum through it (left + node + right). Track global maximum. Return to parent the max single-path sum (node + max of left or right). Ignore negative contributions.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon",
        "Microsoft"
    ],
    "difficulty": "advance",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function maxPathSum(root: TreeNode | null): number {\n    let maxSum = -Infinity;\n    \n    function dfs(node: TreeNode | null): number {\n        if (!node) {\n            return 0;\n        }\n        \n        // Get max sum from left and right (ignore negative paths)\n        const left = Math.max(0, dfs(node.left));\n        const right = Math.max(0, dfs(node.right));\n        \n        // Update global max considering path through this node\n        maxSum = Math.max(maxSum, node.val + left + right);\n        \n        // Return max path sum including this node to parent\n        return node.val + Math.max(left, right);\n    }\n    \n    dfs(root);\n    return maxSum;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def maxPathSum(root: Optional[TreeNode]) -> int:\n    max_sum = float('-inf')\n    \n    def dfs(node):\n        nonlocal max_sum\n        \n        if not node:\n            return 0\n        \n        # Get max sum from left and right (ignore negative paths)\n        left = max(0, dfs(node.left))\n        right = max(0, dfs(node.right))\n        \n        # Update global max considering path through this node\n        max_sum = max(max_sum, node.val + left + right)\n        \n        # Return max path sum including this node to parent\n        return node.val + max(left, right)\n    \n    dfs(root)\n    return max_sum"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "private int maxSum = Integer.MIN_VALUE;\n\npublic int maxPathSum(TreeNode root) {\n    dfs(root);\n    return maxSum;\n}\n\nprivate int dfs(TreeNode node) {\n    if (node == null) {\n        return 0;\n    }\n    \n    // Get max sum from left and right (ignore negative paths)\n    int left = Math.max(0, dfs(node.left));\n    int right = Math.max(0, dfs(node.right));\n    \n    // Update global max considering path through this node\n    maxSum = Math.max(maxSum, node.val + left + right);\n    \n    // Return max path sum including this node to parent\n    return node.val + Math.max(left, right);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int maxSum = INT_MIN;\n\nint maxPathSum(TreeNode* root) {\n    dfs(root);\n    return maxSum;\n}\n\nint dfs(TreeNode* node) {\n    if (!node) {\n        return 0;\n    }\n    \n    // Get max sum from left and right (ignore negative paths)\n    int left = max(0, dfs(node->left));\n    int right = max(0, dfs(node->right));\n    \n    // Update global max considering path through this node\n    maxSum = max(maxSum, node->val + left + right);\n    \n    // Return max path sum including this node to parent\n    return node->val + max(left, right);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "For each node, calculate max path sum through it (left + node + right). Track global maximum. Return to parent the max single-path sum (node + max of left or right). Ignore negative contributions.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=Hr5cWUld4vU",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "advance",
                "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "binary-tree-level-order-traversal": {
    "id": "binary-tree-level-order-traversal",
    "name": "Binary Tree Level Order Traversal",
    "title": "Binary Tree Level Order Traversal",
    "category": "Tree",
    "explanation": {
        "problemStatement": "Given the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).\n\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\n\nConstraints: The number of nodes in the tree is in the range [0, 10^4].",
        "io": [],
        "constraints": [],
        "note": "Use BFS with a queue. Process level by level: store current level size, pop that many nodes, collect values, add children to queue. Each iteration processes one complete level.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Microsoft"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function levelOrder(root: TreeNode | null): number[][] {\n    if (!root) return [];\n    \n    const result: number[][] = [];\n    const queue: TreeNode[] = [root];\n    \n    while (queue.length > 0) {\n        const levelSize = queue.length;\n        const level: number[] = [];\n        \n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift()!;\n            level.push(node.val);\n            \n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        \n        result.push(level);\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def levelOrder(root: Optional[TreeNode]) -> List[List[int]]:\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        level_size = len(queue)\n        level = []\n        \n        for _ in range(level_size):\n            node = queue.pop(0)\n            level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level)\n    \n    return result"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n    \n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    \n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> level = new ArrayList<>();\n        \n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            level.add(node.val);\n            \n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        \n        result.add(level);\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "vector<vector<int>> levelOrder(TreeNode* root) {\n    vector<vector<int>> result;\n    if (!root) return result;\n    \n    queue<TreeNode*> q;\n    q.push(root);\n    \n    while (!q.empty()) {\n        int levelSize = q.size();\n        vector<int> level;\n        \n        for (int i = 0; i < levelSize; i++) {\n            TreeNode* node = q.front();\n            q.pop();\n            level.push_back(node->val);\n            \n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }\n        \n        result.push_back(level);\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use BFS with a queue. Process level by level: store current level size, pop that many nodes, collect values, add children to queue. Each iteration processes one complete level.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=6ZnyEApgFYg",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "serialize-and-deserialize-binary-tree": {
    "id": "serialize-and-deserialize-binary-tree",
    "name": "Serialize and Deserialize Binary Tree",
    "title": "Serialize and Deserialize Binary Tree",
    "category": "Tree",
    "explanation": {
        "problemStatement": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored or transmitted. Design an algorithm to serialize a binary tree to a string and deserialize the string to reconstruct the original tree. There is no restriction on how your serialization/deserialization should work, but they must be consistent.\n\nExample:\nInput: root = [1,2,3,null,null,4,5]\nOutput: (serialized string and then tree reconstructed to original)\n\nConstraints: The number of nodes in the tree is in the range [0, 10^4]; -1000 <= Node.val <= 1000.",
        "io": [],
        "constraints": [],
        "note": "Serialize: use preorder traversal (root, left, right) with 'null' markers for empty nodes. Deserialize: reconstruct using the same preorder sequence by consuming values from queue/iterator.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Google"
    ],
    "difficulty": "advance",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class Codec {\n    serialize(root: TreeNode | null): string {\n        if (!root) return \"null\";\n        \n        return root.val + \",\" + this.serialize(root.left) + \",\" + this.serialize(root.right);\n    }\n    \n    deserialize(data: string): TreeNode | null {\n        const vals = data.split(\",\");\n        let index = 0;\n        \n        const dfs = (): TreeNode | null => {\n            const val = vals[index++];\n            if (val === \"null\") return null;\n            \n            const node = new TreeNode(parseInt(val));\n            node.left = dfs();\n            node.right = dfs();\n            return node;\n        };\n        \n        return dfs();\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class Codec:\n    def serialize(self, root):\n        if not root:\n            return \"null\"\n        \n        # Preorder traversal with null markers\n        return str(root.val) + \",\" + self.serialize(root.left) + \",\" + self.serialize(root.right)\n    \n    def deserialize(self, data):\n        def dfs(vals):\n            val = next(vals)\n            if val == \"null\":\n                return None\n            \n            node = TreeNode(int(val))\n            node.left = dfs(vals)\n            node.right = dfs(vals)\n            return node\n        \n        return dfs(iter(data.split(\",\")))"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public class Codec {\n    public String serialize(TreeNode root) {\n        if (root == null) return \"null\";\n        \n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\n    }\n    \n    public TreeNode deserialize(String data) {\n        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(\",\")));\n        return dfs(queue);\n    }\n    \n    private TreeNode dfs(Queue<String> queue) {\n        String val = queue.poll();\n        if (val.equals(\"null\")) return null;\n        \n        TreeNode node = new TreeNode(Integer.parseInt(val));\n        node.left = dfs(queue);\n        node.right = dfs(queue);\n        return node;\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class Codec {\npublic:\n    string serialize(TreeNode* root) {\n        if (!root) return \"null\";\n        \n        return to_string(root->val) + \",\" + serialize(root->left) + \",\" + serialize(root->right);\n    }\n    \n    TreeNode* deserialize(string data) {\n        queue<string> q;\n        stringstream ss(data);\n        string val;\n        while (getline(ss, val, ',')) {\n            q.push(val);\n        }\n        return dfs(q);\n    }\n    \n    TreeNode* dfs(queue<string>& q) {\n        string val = q.front();\n        q.pop();\n        if (val == \"null\") return nullptr;\n        \n        TreeNode* node = new TreeNode(stoi(val));\n        node->left = dfs(q);\n        node->right = dfs(q);\n        return node;\n    }\n};"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Serialize: use preorder traversal (root, left, right) with 'null' markers for empty nodes. Deserialize: reconstruct using the same preorder sequence by consuming values from queue/iterator.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=u4JAi2JJhI8",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "advance",
                "url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "subtree-of-another-tree": {
    "id": "subtree-of-another-tree",
    "name": "Subtree of Another Tree",
    "title": "Subtree of Another Tree",
    "category": "Tree",
    "explanation": {
        "problemStatement": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root that has the same structure and node values as subRoot, otherwise return false.\n\nExample:\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\nOutput: true\n\nConstraints: The number of nodes in both trees is in the range [0, 2000]; -10^4 <= Node.val <= 10^4.",
        "io": [],
        "constraints": [],
        "note": "For each node in root, check if the tree starting at that node is identical to subRoot using a helper function. Use DFS to traverse all nodes in root tree.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon"
    ],
    "difficulty": "easy",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function isSubtree(root: TreeNode | null, subRoot: TreeNode | null): boolean {\n    function isSame(p: TreeNode | null, q: TreeNode | null): boolean {\n        if (!p && !q) return true;\n        if (!p || !q) return false;\n        \n        return p.val === q.val && isSame(p.left, q.left) && isSame(p.right, q.right);\n    }\n    \n    if (!root) return false;\n    \n    if (isSame(root, subRoot)) return true;\n    \n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n    def isSame(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val == q.val and isSame(p.left, q.left) and isSame(p.right, q.right)\n    \n    if not root:\n        return False\n    \n    # Check if trees are same starting from current root\n    if isSame(root, subRoot):\n        return True\n    \n    # Check left and right subtrees\n    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n    if (root == null) return false;\n    \n    if (isSame(root, subRoot)) return true;\n    \n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n}\n\nprivate boolean isSame(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    \n    return p.val == q.val && isSame(p.left, q.left) && isSame(p.right, q.right);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool isSame(TreeNode* p, TreeNode* q) {\n    if (!p && !q) return true;\n    if (!p || !q) return false;\n    \n    return p->val == q->val && isSame(p->left, q->left) && isSame(p->right, q->right);\n}\n\nbool isSubtree(TreeNode* root, TreeNode* subRoot) {\n    if (!root) return false;\n    \n    if (isSame(root, subRoot)) return true;\n    \n    return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "For each node in root, check if the tree starting at that node is identical to subRoot using a helper function. Use DFS to traverse all nodes in root tree.",
    "timeComplexity": "O(m × n)",
    "spaceComplexity": "O(h)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=E36O5SWp-LE",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "easy",
                "url": "https://leetcode.com/problemset/all/?search=Subtree%20of%20Another%20Tree",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "construct-binary-tree-from-preorder-and-inorder-traversal": {
    "id": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "name": "Construct Binary Tree from Preorder and Inorder Traversal",
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "category": "Tree",
    "explanation": {
        "problemStatement": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\n\nExample:\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n\nConstraints: 1 <= preorder.length <= 3000; inorder.length == preorder.length; -3000 <= Node.val <= 3000; preorder and inorder consist of unique values.",
        "io": [],
        "constraints": [],
        "note": "Use preorder to get root (first element), find root in inorder to determine left/right boundaries. Recursively build left subtree with elements before root in inorder, right subtree with elements after. Use hashmap for O(1) lookups.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon",
        "Microsoft"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n    const inMap = new Map<number, number>();\n    inorder.forEach((val, i) => inMap.set(val, i));\n    \n    let preIndex = 0;\n    \n    function build(left: number, right: number): TreeNode | null {\n        if (left > right) return null;\n        \n        const rootVal = preorder[preIndex++];\n        const root = new TreeNode(rootVal);\n        \n        const mid = inMap.get(rootVal)!;\n        \n        root.left = build(left, mid - 1);\n        root.right = build(mid + 1, right);\n        \n        return root;\n    }\n    \n    return build(0, inorder.length - 1);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def buildTree(preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n    if not preorder or not inorder:\n        return None\n    \n    # First element in preorder is root\n    root = TreeNode(preorder[0])\n    \n    # Find root in inorder to split left/right\n    mid = inorder.index(preorder[0])\n    \n    # Recursively build left and right subtrees\n    root.left = buildTree(preorder[1:mid+1], inorder[:mid])\n    root.right = buildTree(preorder[mid+1:], inorder[mid+1:])\n    \n    return root"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "private int preIndex = 0;\nprivate Map<Integer, Integer> inorderMap = new HashMap<>();\n\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\n    for (int i = 0; i < inorder.length; i++) {\n        inorderMap.put(inorder[i], i);\n    }\n    return build(preorder, 0, inorder.length - 1);\n}\n\nprivate TreeNode build(int[] preorder, int left, int right) {\n    if (left > right) return null;\n    \n    int rootVal = preorder[preIndex++];\n    TreeNode root = new TreeNode(rootVal);\n    \n    int mid = inorderMap.get(rootVal);\n    \n    root.left = build(preorder, left, mid - 1);\n    root.right = build(preorder, mid + 1, right);\n    \n    return root;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n    unordered_map<int, int> inMap;\n    for (int i = 0; i < inorder.size(); i++) {\n        inMap[inorder[i]] = i;\n    }\n    \n    int preIndex = 0;\n    function<TreeNode*(int, int)> build = [&](int left, int right) -> TreeNode* {\n        if (left > right) return nullptr;\n        \n        int rootVal = preorder[preIndex++];\n        TreeNode* root = new TreeNode(rootVal);\n        \n        int mid = inMap[rootVal];\n        \n        root->left = build(left, mid - 1);\n        root->right = build(mid + 1, right);\n        \n        return root;\n    };\n    \n    return build(0, inorder.size() - 1);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use preorder to get root (first element), find root in inorder to determine left/right boundaries. Recursively build left subtree with elements before root in inorder, right subtree with elements after. Use hashmap for O(1) lookups.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=ihj4IQGZ2zc",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "validate-binary-search-tree": {
    "id": "validate-binary-search-tree",
    "name": "Validate Binary Search Tree",
    "title": "Validate Binary Search Tree",
    "category": "Tree",
    "explanation": {
        "problemStatement": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST requires that for every node, all nodes in the left subtree have values less than the node's value, and all nodes in the right subtree have values greater than the node's value.\n\nExample 1:\nInput: root = [2,1,3]\nOutput: true\n\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\n\nConstraints: The number of nodes in the tree is in the range [1, 10^4]; -2^31 <= Node.val <= 2^31 - 1.",
        "io": [],
        "constraints": [],
        "note": "Use DFS with valid range constraints. For each node, check if value is within (min, max). Pass updated ranges to children: left gets (min, node.val), right gets (node.val, max).",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Microsoft"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function isValidBST(root: TreeNode | null): boolean {\n    function validate(node: TreeNode | null, min: number, max: number): boolean {\n        if (!node) return true;\n        \n        if (node.val <= min || node.val >= max) {\n            return false;\n        }\n        \n        return validate(node.left, min, node.val) && \n               validate(node.right, node.val, max);\n    }\n    \n    return validate(root, -Infinity, Infinity);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def isValidBST(root: Optional[TreeNode]) -> bool:\n    def validate(node, min_val, max_val):\n        if not node:\n            return True\n        \n        # Check if current node violates BST property\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        # Validate left subtree (all values < node.val)\n        # and right subtree (all values > node.val)\n        return (validate(node.left, min_val, node.val) and \n                validate(node.right, node.val, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public boolean isValidBST(TreeNode root) {\n    return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\n}\n\nprivate boolean validate(TreeNode node, long min, long max) {\n    if (node == null) return true;\n    \n    if (node.val <= min || node.val >= max) {\n        return false;\n    }\n    \n    return validate(node.left, min, node.val) && \n           validate(node.right, node.val, max);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "bool validate(TreeNode* node, long min, long max) {\n    if (!node) return true;\n    \n    if (node->val <= min || node->val >= max) {\n        return false;\n    }\n    \n    return validate(node->left, min, node->val) && \n           validate(node->right, node->val, max);\n}\n\nbool isValidBST(TreeNode* root) {\n    return validate(root, LONG_MIN, LONG_MAX);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use DFS with valid range constraints. For each node, check if value is within (min, max). Pass updated ranges to children: left gets (min, node.val), right gets (node.val, max).",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=s6ATEkipzow",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "kth-smallest-element-in-a-bst": {
    "id": "kth-smallest-element-in-a-bst",
    "name": "Kth Smallest Element in a BST",
    "title": "Kth Smallest Element in a BST",
    "category": "Tree",
    "explanation": {
        "problemStatement": "Given the root of a binary search tree and an integer k, return the kth smallest value (1-indexed) of all the node values in the tree.\n\nExample:\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\n\nConstraints: The number of nodes in the tree is in the range [1, 10^4]; 1 <= k <= number of nodes; -10^4 <= Node.val <= 10^4.",
        "io": [],
        "constraints": [],
        "note": "Use iterative inorder traversal (left, root, right). In a BST, inorder gives sorted sequence. Stop when we've visited k nodes. Use stack to simulate recursion.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Bloomberg"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function kthSmallest(root: TreeNode | null, k: number): number {\n    const stack: TreeNode[] = [];\n    let curr = root;\n    \n    while (true) {\n        while (curr) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        \n        curr = stack.pop()!;\n        k--;\n        \n        if (k === 0) {\n            return curr.val;\n        }\n        \n        curr = curr.right;\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def kthSmallest(root: Optional[TreeNode], k: int) -> int:\n    # Inorder traversal of BST gives sorted order\n    stack = []\n    curr = root\n    \n    while True:\n        # Go left as far as possible\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n        \n        # Process node\n        curr = stack.pop()\n        k -= 1\n        \n        if k == 0:\n            return curr.val\n        \n        # Go right\n        curr = curr.right"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int kthSmallest(TreeNode root, int k) {\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode curr = root;\n    \n    while (true) {\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        \n        curr = stack.pop();\n        k--;\n        \n        if (k == 0) {\n            return curr.val;\n        }\n        \n        curr = curr.right;\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "int kthSmallest(TreeNode* root, int k) {\n    stack<TreeNode*> st;\n    TreeNode* curr = root;\n    \n    while (true) {\n        while (curr) {\n            st.push(curr);\n            curr = curr->left;\n        }\n        \n        curr = st.top();\n        st.pop();\n        k--;\n        \n        if (k == 0) {\n            return curr->val;\n        }\n        \n        curr = curr->right;\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use iterative inorder traversal (left, root, right). In a BST, inorder gives sorted sequence. Stop when we've visited k nodes. Use stack to simulate recursion.",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=5LUXSvjmGCw",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "lowest-common-ancestor-of-bst": {
    "id": "lowest-common-ancestor-of-bst",
    "name": "Lowest Common Ancestor of BST",
    "title": "Lowest Common Ancestor of BST",
    "category": "Tree",
    "explanation": {
        "problemStatement": "Given a binary search tree (BST) and two nodes p and q, find the lowest common ancestor (LCA) — the deepest node in the tree that has both p and q as descendants (where a node may be a descendant of itself).\n\nExample:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\n\nConstraints: The number of nodes in the tree is in the range [2, 10^4]; -10^5 <= Node.val <= 10^5. p and q will exist in the tree and all Node.val are unique.",
        "io": [],
        "constraints": [],
        "note": "Leverage BST property: if both nodes are smaller than current, go left; if both larger, go right; otherwise current node is the LCA (split point). No recursion needed.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Microsoft"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode {\n    let curr: TreeNode | null = root;\n    \n    while (curr) {\n        if (p.val < curr.val && q.val < curr.val) {\n            curr = curr.left;\n        } else if (p.val > curr.val && q.val > curr.val) {\n            curr = curr.right;\n        } else {\n            return curr;\n        }\n    }\n    \n    return curr!;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n    curr = root\n    \n    while curr:\n        # Both p and q are in left subtree\n        if p.val < curr.val and q.val < curr.val:\n            curr = curr.left\n        # Both p and q are in right subtree\n        elif p.val > curr.val and q.val > curr.val:\n            curr = curr.right\n        # Split point found (or one is ancestor of other)\n        else:\n            return curr\n    \n    return None"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    TreeNode curr = root;\n    \n    while (curr != null) {\n        if (p.val < curr.val && q.val < curr.val) {\n            curr = curr.left;\n        } else if (p.val > curr.val && q.val > curr.val) {\n            curr = curr.right;\n        } else {\n            return curr;\n        }\n    }\n    \n    return null;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    TreeNode* curr = root;\n    \n    while (curr) {\n        if (p->val < curr->val && q->val < curr->val) {\n            curr = curr->left;\n        } else if (p->val > curr->val && q->val > curr->val) {\n            curr = curr->right;\n        } else {\n            return curr;\n        }\n    }\n    \n    return nullptr;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Leverage BST property: if both nodes are smaller than current, go left; if both larger, go right; otherwise current node is the LCA (split point). No recursion needed.",
    "timeComplexity": "O(h)",
    "spaceComplexity": "O(h)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=gs2LMfuOR9k",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "implement-trie": {
    "id": "implement-trie",
    "name": "Implement Trie (Prefix Tree)",
    "title": "Implement Trie (Prefix Tree)",
    "category": "Tree",
    "explanation": {
        "problemStatement": "Implement the Trie (Prefix Tree) data structure with methods insert(word), search(word) and startsWith(prefix).\n\nExample:\nInput:\n[\"Trie\",\"insert\",\"search\",\"search\",\"startsWith\"]\n[[],[\"apple\"],[\"apple\"],[\"app\"],[\"app\"]]\nOutput:\n[null,null,true,false,true]\n\nConstraints: 1 <= word.length, prefix.length <= 2000 across all calls; words consist of lowercase English letters; At most 3 * 10^4 calls will be made to the Trie methods.",
        "io": [],
        "constraints": [],
        "note": "Trie is a tree where each node represents a character. Each node has a map of children and an isEnd flag. Insert: traverse/create path. Search: traverse and check isEnd. StartsWith: just traverse.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Google",
        "Facebook"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class TrieNode {\n    children: Map<string, TrieNode> = new Map();\n    isEnd: boolean = false;\n}\n\nclass Trie {\n    private root: TrieNode;\n    \n    constructor() {\n        this.root = new TrieNode();\n    }\n    \n    insert(word: string): void {\n        let node = this.root;\n        for (const char of word) {\n            if (!node.children.has(char)) {\n                node.children.set(char, new TrieNode());\n            }\n            node = node.children.get(char)!;\n        }\n        node.isEnd = true;\n    }\n    \n    search(word: string): boolean {\n        let node = this.root;\n        for (const char of word) {\n            if (!node.children.has(char)) {\n                return false;\n            }\n            node = node.children.get(char)!;\n        }\n        return node.isEnd;\n    }\n    \n    startsWith(prefix: string): boolean {\n        let node = this.root;\n        for (const char of prefix) {\n            if (!node.children.has(char)) {\n                return false;\n            }\n            node = node.children.get(char)!;\n        }\n        return true;\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n    \n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n    \n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class TrieNode {\n    Map<Character, TrieNode> children = new HashMap<>();\n    boolean isEnd = false;\n}\n\nclass Trie {\n    private TrieNode root;\n    \n    public Trie() {\n        root = new TrieNode();\n    }\n    \n    public void insert(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            node.children.putIfAbsent(c, new TrieNode());\n            node = node.children.get(c);\n        }\n        node.isEnd = true;\n    }\n    \n    public boolean search(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            if (!node.children.containsKey(c)) {\n                return false;\n            }\n            node = node.children.get(c);\n        }\n        return node.isEnd;\n    }\n    \n    public boolean startsWith(String prefix) {\n        TrieNode node = root;\n        for (char c : prefix.toCharArray()) {\n            if (!node.children.containsKey(c)) {\n                return false;\n            }\n            node = node.children.get(c);\n        }\n        return true;\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class TrieNode {\npublic:\n    unordered_map<char, TrieNode*> children;\n    bool isEnd = false;\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\n    \npublic:\n    Trie() {\n        root = new TrieNode();\n    }\n    \n    void insert(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (node->children.find(c) == node->children.end()) {\n                node->children[c] = new TrieNode();\n            }\n            node = node->children[c];\n        }\n        node->isEnd = true;\n    }\n    \n    bool search(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (node->children.find(c) == node->children.end()) {\n                return false;\n            }\n            node = node->children[c];\n        }\n        return node->isEnd;\n    }\n    \n    bool startsWith(string prefix) {\n        TrieNode* node = root;\n        for (char c : prefix) {\n            if (node->children.find(c) == node->children.end()) {\n                return false;\n            }\n            node = node->children[c];\n        }\n        return true;\n    }\n};"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Trie is a tree where each node represents a character. Each node has a map of children and an isEnd flag. Insert: traverse/create path. Search: traverse and check isEnd. StartsWith: just traverse.",
    "timeComplexity": "O(m)",
    "spaceComplexity": "O(m)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=oobqoCJlHA0",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/implement-trie-prefix-tree/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "add-and-search-word": {
    "id": "add-and-search-word",
    "name": "Add and Search Word",
    "title": "Add and Search Word",
    "category": "Tree",
    "explanation": {
        "problemStatement": "Design a data structure that supports adding new words and searching for a string, where the search string may contain the wildcard character '.' that matches any single character. Implement the WordDictionary class with methods addWord(word) and search(word).\n\nExample:\nInput:\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\nOutput:\n[null,null,null,null,false,true,true,true]\n\nConstraints: 1 <= word.length <= 500 across calls; At most 5 * 10^4 calls will be made to addWord and search.",
        "io": [],
        "constraints": [],
        "note": "Same as Trie but search uses DFS. When encountering '.', try all possible children recursively. For regular characters, follow standard Trie search path.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Facebook",
        "Amazon"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class TrieNode {\n    children: Map<string, TrieNode> = new Map();\n    isEnd: boolean = false;\n}\n\nclass WordDictionary {\n    private root: TrieNode;\n    \n    constructor() {\n        this.root = new TrieNode();\n    }\n    \n    addWord(word: string): void {\n        let node = this.root;\n        for (const char of word) {\n            if (!node.children.has(char)) {\n                node.children.set(char, new TrieNode());\n            }\n            node = node.children.get(char)!;\n        }\n        node.isEnd = true;\n    }\n    \n    search(word: string): boolean {\n        const dfs = (node: TrieNode, i: number): boolean => {\n            if (i === word.length) {\n                return node.isEnd;\n            }\n            \n            const char = word[i];\n            if (char === '.') {\n                for (const child of node.children.values()) {\n                    if (dfs(child, i + 1)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                if (!node.children.has(char)) {\n                    return false;\n                }\n                return dfs(node.children.get(char)!, i + 1);\n            }\n        };\n        \n        return dfs(this.root, 0);\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def addWord(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n    \n    def search(self, word: str) -> bool:\n        def dfs(node, i):\n            if i == len(word):\n                return node.is_end\n            \n            if word[i] == '.':\n                # Try all children\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if word[i] not in node.children:\n                    return False\n                return dfs(node.children[word[i]], i + 1)\n        \n        return dfs(self.root, 0)"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class TrieNode {\n    Map<Character, TrieNode> children = new HashMap<>();\n    boolean isEnd = false;\n}\n\nclass WordDictionary {\n    private TrieNode root;\n    \n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            node.children.putIfAbsent(c, new TrieNode());\n            node = node.children.get(c);\n        }\n        node.isEnd = true;\n    }\n    \n    public boolean search(String word) {\n        return dfs(root, word, 0);\n    }\n    \n    private boolean dfs(TrieNode node, String word, int i) {\n        if (i == word.length()) {\n            return node.isEnd;\n        }\n        \n        char c = word.charAt(i);\n        if (c == '.') {\n            for (TrieNode child : node.children.values()) {\n                if (dfs(child, word, i + 1)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            if (!node.children.containsKey(c)) {\n                return false;\n            }\n            return dfs(node.children.get(c), word, i + 1);\n        }\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class TrieNode {\npublic:\n    unordered_map<char, TrieNode*> children;\n    bool isEnd = false;\n};\n\nclass WordDictionary {\nprivate:\n    TrieNode* root;\n    \n    bool dfs(TrieNode* node, const string& word, int i) {\n        if (i == word.length()) {\n            return node->isEnd;\n        }\n        \n        char c = word[i];\n        if (c == '.') {\n            for (auto& [ch, child] : node->children) {\n                if (dfs(child, word, i + 1)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            if (node->children.find(c) == node->children.end()) {\n                return false;\n            }\n            return dfs(node->children[c], word, i + 1);\n        }\n    }\n    \npublic:\n    WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    void addWord(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (node->children.find(c) == node->children.end()) {\n                node->children[c] = new TrieNode();\n            }\n            node = node->children[c];\n        }\n        node->isEnd = true;\n    }\n    \n    bool search(string word) {\n        return dfs(root, word, 0);\n    }\n};"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Same as Trie but search uses DFS. When encountering '.', try all possible children recursively. For regular characters, follow standard Trie search path.",
    "timeComplexity": "O(m)",
    "spaceComplexity": "O(m)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=BTf05gs_8iU",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/add-and-search-word-data-structure-design/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "word-search-ii": {
    "id": "word-search-ii",
    "name": "Word Search II",
    "title": "Word Search II",
    "category": "Tree",
    "explanation": {
        "problemStatement": "Given an m × n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells (horizontal or vertical). The same cell may not be used more than once per word.\n\nExample:\nInput: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\nOutput: [\"oath\",\"eat\"]\n\nConstraints: m == board.length; n == board[i].length; 1 <= m, n <= 12; 1 <= words.length <= 3 * 10^4; 1 <= words[i].length <= 10; board and words consist of lowercase English letters.",
        "io": [],
        "constraints": [],
        "note": "Build Trie from all words. For each cell, do DFS backtracking guided by Trie. Only explore paths that match Trie prefixes. Mark cells visited during DFS. When reaching a word end in Trie, add to results.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Google",
        "Airbnb"
    ],
    "difficulty": "advance",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function findWords(board: string[][], words: string[]): string[] {\n    class TrieNode {\n        children: Map<string, TrieNode> = new Map();\n        word: string | null = null;\n    }\n    \n    // Build Trie\n    const root = new TrieNode();\n    for (const word of words) {\n        let node = root;\n        for (const char of word) {\n            if (!node.children.has(char)) {\n                node.children.set(char, new TrieNode());\n            }\n            node = node.children.get(char)!;\n        }\n        node.word = word;\n    }\n    \n    const result = new Set<string>();\n    const rows = board.length, cols = board[0].length;\n    \n    function dfs(r: number, c: number, node: TrieNode): void {\n        if (r < 0 || r >= rows || c < 0 || c >= cols) return;\n        \n        const char = board[r][c];\n        if (char === '#' || !node.children.has(char)) return;\n        \n        node = node.children.get(char)!;\n        if (node.word) {\n            result.add(node.word);\n        }\n        \n        board[r][c] = '#';\n        dfs(r+1, c, node);\n        dfs(r-1, c, node);\n        dfs(r, c+1, node);\n        dfs(r, c-1, node);\n        board[r][c] = char;\n    }\n    \n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            dfs(r, c, root);\n        }\n    }\n    \n    return Array.from(result);\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def findWords(board: List[List[str]], words: List[str]) -> List[str]:\n    # Build Trie\n    trie = {}\n    for word in words:\n        node = trie\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = word  # Mark end with actual word\n    \n    rows, cols = len(board), len(board[0])\n    result = set()\n    \n    def dfs(r, c, node):\n        char = board[r][c]\n        if char not in node:\n            return\n        \n        node = node[char]\n        \n        # Found a complete word\n        if '$' in node:\n            result.add(node['$'])\n        \n        # Mark visited\n        board[r][c] = '#'\n        \n        # Explore neighbors\n        for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] != '#':\n                dfs(nr, nc, node)\n        \n        # Restore\n        board[r][c] = char\n    \n    for r in range(rows):\n        for c in range(cols):\n            dfs(r, c, trie)\n    \n    return list(result)"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class TrieNode {\n    Map<Character, TrieNode> children = new HashMap<>();\n    String word = null;\n}\n\npublic List<String> findWords(char[][] board, String[] words) {\n    // Build Trie\n    TrieNode root = new TrieNode();\n    for (String word : words) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            node.children.putIfAbsent(c, new TrieNode());\n            node = node.children.get(c);\n        }\n        node.word = word;\n    }\n    \n    Set<String> result = new HashSet<>();\n    int rows = board.length, cols = board[0].length;\n    \n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            dfs(board, r, c, root, result);\n        }\n    }\n    \n    return new ArrayList<>(result);\n}\n\nprivate void dfs(char[][] board, int r, int c, TrieNode node, Set<String> result) {\n    if (r < 0 || r >= board.length || c < 0 || c >= board[0].length) return;\n    \n    char ch = board[r][c];\n    if (ch == '#' || !node.children.containsKey(ch)) return;\n    \n    node = node.children.get(ch);\n    if (node.word != null) {\n        result.add(node.word);\n    }\n    \n    board[r][c] = '#';\n    dfs(board, r+1, c, node, result);\n    dfs(board, r-1, c, node, result);\n    dfs(board, r, c+1, node, result);\n    dfs(board, r, c-1, node, result);\n    board[r][c] = ch;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "struct TrieNode {\n    unordered_map<char, TrieNode*> children;\n    string word = \"\";\n};\n\nvoid dfs(vector<vector<char>>& board, int r, int c, TrieNode* node, set<string>& result) {\n    if (r < 0 || r >= board.size() || c < 0 || c >= board[0].size()) return;\n    \n    char ch = board[r][c];\n    if (ch == '#' || node->children.find(ch) == node->children.end()) return;\n    \n    node = node->children[ch];\n    if (!node->word.empty()) {\n        result.insert(node->word);\n    }\n    \n    board[r][c] = '#';\n    dfs(board, r+1, c, node, result);\n    dfs(board, r-1, c, node, result);\n    dfs(board, r, c+1, node, result);\n    dfs(board, r, c-1, node, result);\n    board[r][c] = ch;\n}\n\nvector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n    TrieNode* root = new TrieNode();\n    for (const string& word : words) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (node->children.find(c) == node->children.end()) {\n                node->children[c] = new TrieNode();\n            }\n            node = node->children[c];\n        }\n        node->word = word;\n    }\n    \n    set<string> result;\n    for (int r = 0; r < board.size(); r++) {\n        for (int c = 0; c < board[0].size(); c++) {\n            dfs(board, r, c, root, result);\n        }\n    }\n    \n    return vector<string>(result.begin(), result.end());\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Build Trie from all words. For each cell, do DFS backtracking guided by Trie. Only explore paths that match Trie prefixes. Mark cells visited during DFS. When reaching a word end in Trie, add to results.",
    "timeComplexity": "O(m × n × 4^L)",
    "spaceComplexity": "O(k)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=asbcE9mZz_U",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "advance",
                "url": "https://leetcode.com/problems/word-search-ii/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "top-k-frequent-elements": {
    "id": "top-k-frequent-elements",
    "name": "Top K Frequent Elements",
    "title": "Top K Frequent Elements",
    "category": "Heap",
    "explanation": {
        "problemStatement": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\n\nExample 1:\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n\nConstraints: 1 <= nums.length <= 10^5; k is in the range [1, number of unique elements]; Answer is guaranteed to exist.",
        "io": [],
        "constraints": [],
        "note": "Use bucket sort for O(n) solution. Count frequencies, then create buckets where index=frequency. Iterate from highest frequency bucket collecting elements until we have k elements.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Facebook",
        "Yelp"
    ],
    "difficulty": "intermediate",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function topKFrequent(nums: number[], k: number): number[] {\n    const count = new Map<number, number>();\n    for (const num of nums) {\n        count.set(num, (count.get(num) || 0) + 1);\n    }\n    \n    const freq: number[][] = Array.from({ length: nums.length + 1 }, () => []);\n    for (const [num, c] of count) {\n        freq[c].push(num);\n    }\n    \n    const result: number[] = [];\n    for (let i = freq.length - 1; i >= 0 && result.length < k; i--) {\n        for (const num of freq[i]) {\n            result.push(num);\n            if (result.length === k) return result;\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "def topKFrequent(nums: List[int], k: int) -> List[int]:\n    # Count frequencies\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    # Bucket sort: index = frequency, value = list of numbers\n    freq = [[] for _ in range(len(nums) + 1)]\n    for num, c in count.items():\n        freq[c].append(num)\n    \n    # Collect top k from highest frequency\n    result = []\n    for i in range(len(freq) - 1, 0, -1):\n        for num in freq[i]:\n            result.append(num)\n            if len(result) == k:\n                return result\n    \n    return result"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "public int[] topKFrequent(int[] nums, int k) {\n    Map<Integer, Integer> count = new HashMap<>();\n    for (int num : nums) {\n        count.put(num, count.getOrDefault(num, 0) + 1);\n    }\n    \n    List<Integer>[] freq = new List[nums.length + 1];\n    for (int i = 0; i <= nums.length; i++) {\n        freq[i] = new ArrayList<>();\n    }\n    \n    for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n        freq[entry.getValue()].add(entry.getKey());\n    }\n    \n    int[] result = new int[k];\n    int idx = 0;\n    \n    for (int i = freq.length - 1; i >= 0 && idx < k; i--) {\n        for (int num : freq[i]) {\n            result[idx++] = num;\n            if (idx == k) return result;\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "vector<int> topKFrequent(vector<int>& nums, int k) {\n    unordered_map<int, int> count;\n    for (int num : nums) {\n        count[num]++;\n    }\n    \n    vector<vector<int>> freq(nums.size() + 1);\n    for (auto& [num, c] : count) {\n        freq[c].push_back(num);\n    }\n    \n    vector<int> result;\n    for (int i = freq.size() - 1; i >= 0 && result.size() < k; i--) {\n        for (int num : freq[i]) {\n            result.push_back(num);\n            if (result.size() == k) return result;\n        }\n    }\n    \n    return result;\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use bucket sort for O(n) solution. Count frequencies, then create buckets where index=frequency. Iterate from highest frequency bucket collecting elements until we have k elements.",
    "timeComplexity": "O(n log k)",
    "spaceComplexity": "O(n + k)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=YPTqKIgVk-k",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "intermediate",
                "url": "https://leetcode.com/problems/top-k-frequent-elements/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
  "find-median-from-data-stream": {
    "id": "find-median-from-data-stream",
    "name": "Find Median from Data Stream",
    "title": "Find Median from Data Stream",
    "category": "Heap",
    "explanation": {
        "problemStatement": "Design a data structure that supports adding numbers from a data stream and finding the median of all numbers seen so far efficiently.\n\nExample:\naddNum(1)\naddNum(2)\nfindMedian() -> 1.5\naddNum(3)\nfindMedian() -> 2\n\nConstraints: At most 10^5 calls will be made to addNum and findMedian; Values are 32-bit signed integers.",
        "io": [],
        "constraints": [],
        "note": "Use two heaps: max heap for smaller half, min heap for larger half. Keep sizes balanced (small can have 1 more). Median is either top of small (odd count) or average of both tops (even count). O(log n) per operation.",
        "steps": [],
        "useCase": "",
        "tips": []
    },
    "companyTags": [
        "Amazon",
        "Google",
        "Facebook"
    ],
    "difficulty": "advance",
    "listType": "blind75",
    "visualizationUrl": "",
    "commonNotes": "",
    "commonWhiteBoard": "",
    "implementations": [
        {
            "lang": "typeScript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class MedianFinder {\n    private small: MaxHeap;  // smaller half\n    private large: MinHeap;  // larger half\n    \n    constructor() {\n        this.small = new MaxHeap();\n        this.large = new MinHeap();\n    }\n    \n    addNum(num: number): void {\n        this.small.push(num);\n        \n        if (this.small.size() > 0 && this.large.size() > 0 && \n            this.small.peek()! > this.large.peek()!) {\n            this.large.push(this.small.pop()!);\n        }\n        \n        if (this.small.size() > this.large.size() + 1) {\n            this.large.push(this.small.pop()!);\n        }\n        if (this.large.size() > this.small.size()) {\n            this.small.push(this.large.pop()!);\n        }\n    }\n    \n    findMedian(): number {\n        if (this.small.size() > this.large.size()) {\n            return this.small.peek()!;\n        }\n        return (this.small.peek()! + this.large.peek()!) / 2.0;\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "python",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # Max heap for smaller half (negate values)\n        self.small = []\n        # Min heap for larger half\n        self.large = []\n    \n    def addNum(self, num: int) -> None:\n        # Add to small heap (max heap using negation)\n        heapq.heappush(self.small, -num)\n        \n        # Balance: ensure max of small <= min of large\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        \n        # Balance sizes (small can have at most 1 more element)\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n    \n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0"
                },
                {
                    "codeType": "starter",
                    "code": "# TODO: Starter code"
                }
            ]
        },
        {
            "lang": "java",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class MedianFinder {\n    private PriorityQueue<Integer> small; // max heap\n    private PriorityQueue<Integer> large; // min heap\n    \n    public MedianFinder() {\n        small = new PriorityQueue<>((a, b) -> b - a);\n        large = new PriorityQueue<>();\n    }\n    \n    public void addNum(int num) {\n        small.offer(num);\n        \n        if (!small.isEmpty() && !large.isEmpty() && small.peek() > large.peek()) {\n            large.offer(small.poll());\n        }\n        \n        if (small.size() > large.size() + 1) {\n            large.offer(small.poll());\n        }\n        if (large.size() > small.size()) {\n            small.offer(large.poll());\n        }\n    }\n    \n    public double findMedian() {\n        if (small.size() > large.size()) {\n            return small.peek();\n        }\n        return (small.peek() + large.peek()) / 2.0;\n    }\n}"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        },
        {
            "lang": "cpp",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "class MedianFinder {\nprivate:\n    priority_queue<int> small; // max heap\n    priority_queue<int, vector<int>, greater<int>> large; // min heap\n    \npublic:\n    MedianFinder() {}\n    \n    void addNum(int num) {\n        small.push(num);\n        \n        if (!small.empty() && !large.empty() && small.top() > large.top()) {\n            large.push(small.top());\n            small.pop();\n        }\n        \n        if (small.size() > large.size() + 1) {\n            large.push(small.top());\n            small.pop();\n        }\n        if (large.size() > small.size()) {\n            small.push(large.top());\n            large.pop();\n        }\n    }\n    \n    double findMedian() {\n        if (small.size() > large.size()) {\n            return small.top();\n        }\n        return (small.top() + large.top()) / 2.0;\n    }\n};"
                },
                {
                    "codeType": "starter",
                    "code": "// TODO: Starter code"
                }
            ]
        }
    ],
    "overview": "Use two heaps: max heap for smaller half, min heap for larger half. Keep sizes balanced (small can have 1 more). Median is either top of small (odd count) or average of both tops (even count). O(log n) per operation.",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(n)",
    "tutorials": [
        {
            "type": "youtube",
            "url": "https://www.youtube.com/watch?v=itmhHWaHupI",
            "credits": "NeetCode",
            "moreInfo": ""
        }
    ],
    "likes": 0,
    "dislikes": 0,
    "problemsToSolve": {
        "internal": [],
        "external": [
            {
                "type": "advance",
                "url": "https://leetcode.com/problems/find-median-from-data-stream/",
                "title": "LeetCode Problem"
            }
        ]
    },
    "imageUrls": [],
    "testCases": [],
    "inputSchema": [],
    "availableLanguages": "typeScript,python,java,cpp",
    "editorialId": "",
    "userCompletionGraphData": {
        "attempted": 0,
        "completed": 0
    },
    "shareCount": 0
},
