# Welcome to Algo Learn 🚀

AlgoLib.io is an open-source platform to **learn, visualize, and master algorithms** with interactive explanations and multi-language code snippets (Python, Java, C++, and TypeScript).

🌐 **Visit Live:** [https://algolib.io](https://algolib.io)

---

## 📚 Algorithm Index

<details>
<summary><strong>Arrays & Strings</strong></summary>

- [Two Pointers](https://algolib.io/algorithms/two-pointers) — Use two pointers to traverse arrays efficiently
- [Sliding Window](https://algolib.io/algorithms/sliding-window) — Maintain a window of elements for efficient computation
- [Prefix Sum](https://algolib.io/algorithms/prefix-sum) — Pre-compute cumulative sums for range queries
- [Binary Search](https://algolib.io/algorithms/binary-search) — Search in sorted arrays in logarithmic time
- [Kadane's Algorithm](https://algolib.io/algorithms/kadanes-algorithm) — Find maximum subarray sum efficiently
- [Dutch National Flag](https://algolib.io/algorithms/dutch-national-flag) — Sort array of three distinct elements
- [Merge Intervals](https://algolib.io/algorithms/merge-intervals) — Merge overlapping intervals
- [Monotonic Stack](https://algolib.io/algorithms/monotonic-stack) — Stack with monotonic properties for efficient queries
- [Rotate Array In-Place](https://algolib.io/algorithms/rotate-array) — Rotate array elements without extra space
- [Cyclic Sort](https://algolib.io/algorithms/cyclic-sort) — Sort by placing elements at their correct index

</details>

<details>
<summary><strong>Linked List</strong></summary>

- [Fast & Slow Pointers](https://algolib.io/algorithms/fast-slow-pointers) — Detect cycles and find middle using two pointers
- [Reverse Linked List](https://algolib.io/algorithms/reverse-linked-list) — Reverse a singly linked list
- [Merge Two Sorted Lists](https://algolib.io/algorithms/merge-sorted-lists) — Merge two sorted linked lists
- [Detect Cycle](https://algolib.io/algorithms/detect-cycle) — Floyd's algorithm to detect cycles
- [Middle Node](https://algolib.io/algorithms/middle-node) — Find middle node using fast and slow pointers

</details>

<details>
<summary><strong>Trees & BSTs</strong></summary>

- [DFS Preorder](https://algolib.io/algorithms/dfs-preorder) — Visit root, left, then right subtree
- [DFS Inorder](https://algolib.io/algorithms/dfs-inorder) — Visit left, root, then right subtree
- [DFS Postorder](https://algolib.io/algorithms/dfs-postorder) — Visit left, right, then root
- [BFS Level Order](https://algolib.io/algorithms/bfs-level-order) — Traverse tree level by level
- [BST Insert](https://algolib.io/algorithms/bst-insert) — Insert node in binary search tree
- [Lowest Common Ancestor](https://algolib.io/algorithms/lca) — Find LCA of two nodes in tree
- [Recover BST](https://algolib.io/algorithms/recover-bst) — Fix BST with two swapped nodes
- [Serialize Tree](https://algolib.io/algorithms/serialize-tree) — Serialize and deserialize binary tree
- [Trie (Prefix Tree)](https://algolib.io/algorithms/trie) — Efficient string storage and retrieval

</details>

<details>
<summary><strong>Graphs</strong></summary>

- [Graph DFS](https://algolib.io/algorithms/graph-dfs) — Depth-first traversal of graphs
- [Graph BFS](https://algolib.io/algorithms/graph-bfs) — Breadth-first traversal of graphs
- [Topological Sort](https://algolib.io/algorithms/topological-sort) — Kahn's algorithm for DAG ordering
- [Union-Find](https://algolib.io/algorithms/union-find) — Disjoint set data structure
- [Kruskal's Algorithm](https://algolib.io/algorithms/kruskals) — Find minimum spanning tree
- [Prim's Algorithm](https://algolib.io/algorithms/prims) — Find MST using greedy approach
- [Dijkstra's Algorithm](https://algolib.io/algorithms/dijkstras) — Single-source shortest path
- [Bellman-Ford](https://algolib.io/algorithms/bellman-ford) — Shortest path with negative weights
- [Floyd-Warshall](https://algolib.io/algorithms/floyd-warshall) — All-pairs shortest paths
- [A* Search](https://algolib.io/algorithms/a-star) — Heuristic pathfinding algorithm

</details>

<details>
<summary><strong>Dynamic Programming</strong></summary>

- [0/1 Knapsack](https://algolib.io/algorithms/knapsack-01) — Maximize value with weight constraint
- [Coin Change](https://algolib.io/algorithms/coin-change) — Minimum coins for target amount
- [Longest Common Subsequence](https://algolib.io/algorithms/lcs) — Find longest common subsequence
- [Longest Increasing Subsequence](https://algolib.io/algorithms/lis) — Find LIS in array
- [Edit Distance](https://algolib.io/algorithms/edit-distance) — Minimum edits to transform strings
- [Matrix Path DP](https://algolib.io/algorithms/matrix-path-dp) — Find unique or minimum paths in matrix
- [Partition Equal Subset](https://algolib.io/algorithms/partition-equal-subset) — Check if array can be partitioned equally
- [House Robber](https://algolib.io/algorithms/house-robber) — Maximum sum without adjacent elements
- [Climbing Stairs](https://algolib.io/algorithms/climbing-stairs) — Count ways to climb n stairs
- [Word Break](https://algolib.io/algorithms/word-break) — Segment string into dictionary words

</details>

<details>
<summary><strong>Greedy</strong></summary>

- [Activity Selection](https://algolib.io/algorithms/activity-selection) — Select maximum non-overlapping activities
- [Interval Scheduling](https://algolib.io/algorithms/interval-scheduling) — Schedule intervals optimally
- [Huffman Encoding](https://algolib.io/algorithms/huffman-encoding) — Optimal prefix-free encoding
- [Gas Station](https://algolib.io/algorithms/gas-station) — Find starting station for circular tour

</details>

<details>
<summary><strong>Backtracking</strong></summary>

- [Subsets](https://algolib.io/algorithms/subsets) — Generate all subsets of a set
- [Permutations](https://algolib.io/algorithms/permutations) — Generate all permutations
- [Combinations](https://algolib.io/algorithms/combinations) — Generate all k-combinations
- [Combination Sum](https://algolib.io/algorithms/combination-sum) — Find combinations summing to target
- [Word Search](https://algolib.io/algorithms/word-search-grid) — Find word in 2D grid
- [N-Queens](https://algolib.io/algorithms/n-queens) — Place N queens on N×N board
- [Sudoku Solver](https://algolib.io/algorithms/sudoku-solver) — Solve Sudoku puzzle

</details>

<details>
<summary><strong>Bit Manipulation</strong></summary>

- [XOR Trick](https://algolib.io/algorithms/xor-trick) — Find single number using XOR
- [Count Bits](https://algolib.io/algorithms/count-bits) — Brian Kernighan's algorithm
- [Subset Generation with Bits](https://algolib.io/algorithms/subset-generation-bits) — Generate subsets using bitmasks

</details>

<details>
<summary><strong>Heap / Priority Queue</strong></summary>

- [Kth Largest Element](https://algolib.io/algorithms/kth-largest) — Find kth largest using min heap
- [Merge K Sorted Lists](https://algolib.io/algorithms/merge-k-lists) — Merge using min heap
- [Sliding Window Maximum](https://algolib.io/algorithms/sliding-window-maximum) — Find max in each window

</details>

<details>
<summary><strong>Math & Number Theory</strong></summary>

- [GCD (Euclidean)](https://algolib.io/algorithms/gcd-euclidean) — Euclid's algorithm for GCD
- [Sieve of Eratosthenes](https://algolib.io/algorithms/sieve-eratosthenes) — Generate all primes up to n
- [Modular Exponentiation](https://algolib.io/algorithms/modular-exponentiation) — Fast power with modulo
- [Karatsuba Multiplication](https://algolib.io/algorithms/karatsuba) — Fast multiplication algorithm

</details>

<details>
<summary><strong>Advanced</strong></summary>

- [Segment Tree](https://algolib.io/algorithms/segment-tree) — Range query data structure
- [Fenwick Tree (BIT)](https://algolib.io/algorithms/fenwick-tree) — Binary indexed tree for prefix sums
- [Sparse Table](https://algolib.io/algorithms/sparse-table) — Range minimum query in O(1)
- [KMP String Matching](https://algolib.io/algorithms/kmp) — Linear time pattern matching
- [Rabin-Karp](https://algolib.io/algorithms/rabin-karp) — Rolling hash pattern matching
- [Manacher's Algorithm](https://algolib.io/algorithms/manachers) — Longest palindromic substring
- [Union by Rank + Path Compression](https://algolib.io/algorithms/union-by-rank) — Optimized union-find
- [Tarjan's Algorithm](https://algolib.io/algorithms/tarjans) — Find strongly connected components
- [Binary Lifting](https://algolib.io/algorithms/binary-lifting) — LCA using binary lifting

</details>

---

## 🧠 How can I edit this code?

There are several ways of editing your application.

### 🖥️ Use your preferred IDE

If you want to work locally using your own IDE, you can clone this repo and push changes.  
Pushed changes will also be reflected in Lovable.

The only requirement is having Node.js & npm installed - [install with nvm](https://github.com/nvm-sh/nvm#installing-and-updating)

Follow these steps:

```bash
# Step 1: Install dependencies
npm i

# Step 2: Start development server
npm run dev
```

### ✏️ Edit directly in GitHub

- Navigate to the desired file(s)
- Click the pencil ✏️ icon at top-right of the file
- Make your changes and commit

### 💻 Use GitHub Codespaces

- Navigate to the main page of your repository
- Click on **Code → Codespaces → New Codespace**
- Edit files directly within the Codespace and commit when done

---

## 🧰 Tech Stack

- ⚡ Vite  
- 💎 TypeScript  
- ⚛️ React  
- 🎨 shadcn/ui  
- 💨 Tailwind CSS  

---

## 🤝 Contribute

We welcome contributions!  
Help us expand AlgoLib.io with more algorithms, better explanations, and improved visualizations.

Fork → Edit → Pull Request.

⭐ **Star this repo** if you find it helpful!
