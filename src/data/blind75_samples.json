[
  {
    "id": "two-sum",
    "title": "Two Sum",
    "name": "Two Sum",
    "category": "Arrays & Hashing",
    "difficulty": "easy",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
    "serial_no": 1,
    "list_type": "blind75",
    "explanation": {
      "problemStatement": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
      "steps": [
        "Initialize an empty hash map to store numbers and their indices.",
        "Iterate through the array of numbers.",
        "For each number 'n', calculate the complement (target - n).",
        "Check if the complement exists in the map.",
        "If it exists, return the indices [map[complement], current_index].",
        "If not, add the current number and its index to the map."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "constraints": [
        "2 <= nums.length <= 10^4",
        "-10^9 <= nums[i] <= 10^9",
        "-10^9 <= target <= 10^9",
        "Only one valid answer exists."
      ]
    },
    "implementations": [
      {
        "lang": "typescript",
        "code": [
          {
            "codeType": "starter",
            "code": "function twoSum(nums: number[], target: number): number[] {\n    \n}"
          },
          {
            "codeType": "optimize",
            "code": "function twoSum(nums: number[], target: number): number[] {\n    const map = new Map<number, number>();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            return [map.get(complement)!, i];\n        }\n        map.set(nums[i], i);\n    }\n    return [];\n}"
          }
        ]
      }
    ],
    "test_cases": [
      {
        "input": [[2, 7, 11, 15], 9],
        "output": [0, 1],
        "description": "Basic example"
      },
      {
        "input": [[3, 2, 4], 6],
        "output": [1, 2],
        "description": "Target is sum of last two"
      },
      {
        "input": [[3, 3], 6],
        "output": [0, 1],
        "description": "Duplicate numbers"
      }
    ],
    "input_schema": [
      { "name": "nums", "type": "number[]", "label": "Numbers" },
      { "name": "target", "type": "number", "label": "Target" }
    ],
    "metadata": {
      "companyTags": ["Amazon", "Google", "Apple", "Adobe", "Microsoft"],
      "likes": 50000,
      "dislikes": 1600
    }
  },
  {
    "id": "best-time-to-buy-and-sell-stock",
    "title": "Best Time to Buy and Sell Stock",
    "name": "Best Time to Buy and Sell Stock",
    "category": "Arrays & Hashing",
    "difficulty": "easy",
    "description": "You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.",
    "serial_no": 2,
    "list_type": "blind75",
    "explanation": {
      "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
      "steps": [
        "Initialize minPrice to infinity and maxProfit to 0.",
        "Iterate through the prices array.",
        "If current price is less than minPrice, update minPrice.",
        "Else if (current price - minPrice) is greater than maxProfit, update maxProfit.",
        "Return maxProfit."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "constraints": [
        "1 <= prices.length <= 10^5",
        "0 <= prices[i] <= 10^4"
      ]
    },
    "implementations": [
      {
        "lang": "typescript",
        "code": [
            {
                "codeType": "starter",
                "code": "function maxProfit(prices: number[]): number {\n    \n}"
            },
            {
                "codeType": "optimize",
                "code": "function maxProfit(prices: number[]): number {\n    let minPrice = Infinity;\n    let maxProfit = 0;\n    for (let i = 0; i < prices.length; i++) {\n        if (prices[i] < minPrice) {\n            minPrice = prices[i];\n        } else if (prices[i] - minPrice > maxProfit) {\n            maxProfit = prices[i] - minPrice;\n        }\n    }\n    return maxProfit;\n}"
            }
        ]
      }
    ],
    "test_cases": [
      {
        "input": [[7, 1, 5, 3, 6, 4]],
        "output": 5,
        "description": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": [[7, 6, 4, 3, 1]],
        "output": 0,
        "description": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "input_schema": [
        { "name": "prices", "type": "number[]", "label": "Prices" }
    ],
    "metadata": {
      "companyTags": ["Amazon", "Bloomberg", "Google", "Facebook", "Microsoft"],
      "likes": 28000,
      "dislikes": 900
    }
  },
  {
    "id": "contains-duplicate",
    "title": "Contains Duplicate",
    "name": "Contains Duplicate",
    "category": "Arrays & Hashing",
    "difficulty": "easy",
    "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
    "serial_no": 3,
    "list_type": "blind75",
    "explanation": {
        "problemStatement": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
        "steps": [
            "Initialize a Set.",
            "Iterate through the array.",
            "For each element, check if it's already in the Set.",
            "If yes, return true.",
            "If no, add it to the Set.",
            "If the loop finishes, return false."
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "constraints": [
            "1 <= nums.length <= 10^5",
            "-10^9 <= nums[i] <= 10^9"
        ]
    },
    "implementations": [
        {
            "lang": "typescript",
            "code": [
                {
                    "codeType": "starter",
                    "code": "function containsDuplicate(nums: number[]): boolean {\n    \n}"
                },
                {
                    "codeType": "optimize",
                    "code": "function containsDuplicate(nums: number[]): boolean {\n    const set = new Set(nums);\n    return set.size !== nums.length;\n}"
                }
            ]
        }
    ],
    "test_cases": [
        {
            "input": [[1, 2, 3, 1]],
            "output": true,
            "description": "Has duplicates"
        },
        {
            "input": [[1, 2, 3, 4]],
            "output": false,
            "description": "No duplicates"
        },
        {
            "input": [[1, 1, 1, 3, 3, 4, 3, 2, 4, 2]],
            "output": true,
            "description": "Multiple duplicates"
        }
    ],
    "input_schema": [
        { "name": "nums", "type": "number[]", "label": "Numbers" }
    ],
    "metadata": {
        "companyTags": ["Apple", "Microsoft", "Adobe"],
        "likes": 10000,
        "dislikes": 1200
    }
  },
  {
    "id": "product-of-array-except-self",
    "title": "Product of Array Except Self",
    "name": "Product of Array Except Self",
    "category": "Arrays & Hashing",
    "difficulty": "medium",
    "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
    "serial_no": 4,
    "list_type": "blind75",
    "explanation": {
        "problemStatement": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation.",
        "steps": [
            "Init result array with 1s.",
            "Calculate prefix products: Loop from left to right, storing product of all previous elements.",
            "Calculate suffix products: Loop from right to left, multiplying current result by product of all following elements.",
            "Return result."
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1) (excluding output array)"
    },
    "implementations": [
        {
            "lang": "typescript",
            "code": [
                {
                    "codeType": "starter",
                    "code": "function productExceptSelf(nums: number[]): number[] {\n    \n}"
                },
                {
                    "codeType": "optimize",
                    "code": "function productExceptSelf(nums: number[]): number[] {\n    const n = nums.length;\n    const res = new Array(n).fill(1);\n    let prefix = 1;\n    for (let i = 0; i < n; i++) {\n        res[i] = prefix;\n        prefix *= nums[i];\n    }\n    let postfix = 1;\n    for (let i = n - 1; i >= 0; i--) {\n        res[i] *= postfix;\n        postfix *= nums[i];\n    }\n    return res;\n}"
                }
            ]
        }
    ],
    "test_cases": [
        {
            "input": [[1, 2, 3, 4]],
            "output": [24, 12, 8, 6],
            "description": "Standard case"
        },
        {
            "input": [[-1, 1, 0, -3, 3]],
            "output": [0, 0, 9, 0, 0],
            "description": "With zero and negatives"
        }
    ],
    "input_schema": [
        { "name": "nums", "type": "number[]", "label": "Numbers" }
    ],
    "metadata": {
        "companyTags": ["Amazon", "Facebook", "Microsoft", "Apple", "Asana"],
        "likes": 18000,
        "dislikes": 1000
    }
  },
  {
    "id": "maximum-subarray",
    "title": "Maximum Subarray",
    "name": "Maximum Subarray",
    "category": "Arrays & Hashing",
    "difficulty": "medium",
    "description": "Find the subarray with the largest sum and return its sum.",
    "serial_no": 5,
    "list_type": "blind75",
    "explanation": {
        "problemStatement": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
        "steps": [
            "Initialize maxSub to nums[0] and curSum to 0.",
            "Iterate through nums.",
            "If curSum is negative, reset it to 0.",
            "Add current num to curSum.",
            "Update maxSub if curSum is greater.",
            "Return maxSub."
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
    },
    "implementations": [
        {
            "lang": "typescript",
            "code": [
                {
                    "codeType": "optimize",
                    "code": "function maxSubArray(nums: number[]): number {\n    let maxSub = nums[0];\n    let curSum = 0;\n    for (const n of nums) {\n        if (curSum < 0) curSum = 0;\n        curSum += n;\n        maxSub = Math.max(maxSub, curSum);\n    }\n    return maxSub;\n}"
                }
            ]
        }
    ],
    "test_cases": [
        {
            "input": [[-2,1,-3,4,-1,2,1,-5,4]],
            "output": 6,
            "description": "Subarray [4,-1,2,1] has the largest sum = 6."
        },
        {
            "input": [[1]],
            "output": 1,
            "description": "Single element"
        },
        {
            "input": [[5,4,-1,7,8]],
            "output": 23,
            "description": "All positive path"
        }
    ],
    "input_schema": [
        { "name": "nums", "type": "number[]", "label": "Numbers" }
    ],
    "metadata": {
        "companyTags": ["LinkedIn", "Apple", "Microsoft"],
        "likes": 30000,
        "dislikes": 1200
    }
  },
  {
      "id": "maximum-product-subarray",
      "title": "Maximum Product Subarray",
      "name": "Maximum Product Subarray",
      "category": "Arrays & Hashing",
      "difficulty": "medium",
      "description": "Find the subarray that has the largest product and return the product.",
      "serial_no": 6,
      "list_type": "blind75",
      "explanation": {
          "problemStatement": "Given an integer array nums, find a subarray that has the largest product, and return the product.",
          "steps": [
              "Track min and max product ending at current position.",
              "If current number is negative, swap min and max.",
              "Update max = max(n, max * n), min = min(n, min * n).",
              "Update global result."
          ],
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
      },
      "implementations": [
          {
              "lang": "typescript",
              "code": [
                   {
                      "codeType": "optimize",
                      "code": "function maxProduct(nums: number[]): number {\n    let res = Math.max(...nums);\n    let curMin = 1;\n    let curMax = 1;\n    for (const n of nums) {\n        if (n === 0) {\n            curMin = 1;\n            curMax = 1;\n            continue;\n        }\n        const tmp = curMax * n;\n        curMax = Math.max(n * curMax, n * curMin, n);\n        curMin = Math.min(tmp, n * curMin, n);\n        res = Math.max(res, curMax);\n    }\n    return res;\n}"
                   }
              ]
          }
      ],
      "test_cases": [
          {
              "input": [[2,3,-2,4]],
              "output": 6,
              "description": "[2,3] has the largest product 6."
          },
          {
              "input": [[-2,0,-1]],
              "output": 0,
              "description": "Result must be a subarray."
          }
      ],
      "input_schema": [
          { "name": "nums", "type": "number[]", "label": "Numbers" }
      ],
      "metadata": {
          "companyTags": ["Amazon", "LinkedIn", "Google"],
          "likes": 16000,
          "dislikes": 500
      }
  },
   {
      "id": "find-minimum-in-rotated-sorted-array",
      "title": "Find Minimum in Rotated Sorted Array",
      "name": "Find Minimum in Rotated Sorted Array",
      "category": "Binary Search",
      "difficulty": "medium",
      "description": "Find the minimum element in a sorted array that has been rotated.",
      "serial_no": 7,
      "list_type": "blind75",
      "explanation": {
          "problemStatement": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. Find the minimum element of this array.",
          "steps": [
              "Use binary search.",
              "If mid > right, minimum is in right half (left = mid + 1).",
              "Else, minimum is in left half (right = mid).",
              "When left == right, we found the minimum."
          ],
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)"
      },
      "implementations": [
          {
              "lang": "typescript",
              "code": [
                   {
                      "codeType": "optimize",
                      "code": "function findMin(nums: number[]): number {\n    let left = 0;\n    let right = nums.length - 1;\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}"
                   }
              ]
          }
      ],
      "test_cases": [
          {
              "input": [[3,4,5,1,2]],
              "output": 1,
              "description": "Rotated at index 3"
          },
          {
              "input": [[4,5,6,7,0,1,2]],
              "output": 0,
              "description": "Rotated at index 4"
          },
          {
              "input": [[11,13,15,17]],
              "output": 11,
              "description": "Not rotated"
          }
      ],
      "input_schema": [
          { "name": "nums", "type": "number[]", "label": "Numbers" }
      ],
      "metadata": {
          "companyTags": ["Facebook", "Microsoft", "Amazon"],
          "likes": 12000,
          "dislikes": 500
      }
  },
  {
      "id": "search-in-rotated-sorted-array",
      "title": "Search in Rotated Sorted Array",
      "name": "Search in Rotated Sorted Array",
      "category": "Binary Search",
      "difficulty": "medium",
      "description": "Search for a target value in a rotated sorted array. If found return its index, otherwise -1.",
      "serial_no": 8,
      "list_type": "blind75",
      "explanation": {
          "problemStatement": "There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.",
          "steps": [
              "Binary search.",
              "Determine which half is sorted.",
              "If left half sorted: check if target is within left range.",
              "If right half sorted: check if target is within right range.",
              "Adjust pointers accordingly."
          ],
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)"
      },
      "implementations": [
          {
              "lang": "typescript",
              "code": [
                   {
                      "codeType": "optimize",
                      "code": "function search(nums: number[], target: number): number {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        if (nums[mid] === target) return mid;\n\n        if (nums[left] <= nums[mid]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}"
                   }
              ]
          }
      ],
      "test_cases": [
          {
              "input": [[4,5,6,7,0,1,2], 0],
              "output": 4,
              "description": "Found at index 4"
          },
          {
              "input": [[4,5,6,7,0,1,2], 3],
              "output": -1,
              "description": "Not found"
          }
      ],
      "input_schema": [
          { "name": "nums", "type": "number[]", "label": "Numbers" },
          { "name": "target", "type": "number", "label": "Target" }
      ],
      "metadata": {
          "companyTags": ["LinkedIn", "Facebook", "Microsoft"],
          "likes": 22000,
          "dislikes": 1200
      }
  },
  {
      "id": "3sum",
      "title": "3Sum",
      "name": "3Sum",
      "category": "Arrays & Hashing",
      "difficulty": "medium",
      "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
      "serial_no": 9,
      "list_type": "blind75",
      "explanation": {
          "problemStatement": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
          "steps": [
              "Sort the array.",
              "Iterate with index 'i' from 0 to n-2.",
              "If nums[i] > 0, break (since sorted).",
              "Use two pointers (left, right) for the remaining part to find sum = -nums[i].",
              "Skip duplicates for i, left, and right."
          ],
          "timeComplexity": "O(n^2)",
          "spaceComplexity": "O(1) (or O(n) for sort)"
      },
      "implementations": [
          {
              "lang": "typescript",
              "code": [
                   {
                      "codeType": "optimize",
                      "code": "function threeSum(nums: number[]): number[][] {\n    nums.sort((a, b) => a - b);\n    const res: number[][] = [];\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        let l = i + 1;\n        let r = nums.length - 1;\n        while (l < r) {\n            const sum = nums[i] + nums[l] + nums[r];\n            if (sum > 0) r--;\n            else if (sum < 0) l++;\n            else {\n                res.push([nums[i], nums[l], nums[r]]);\n                l++;\n                while (nums[l] === nums[l - 1] && l < r) l++;\n            }\n        }\n    }\n    return res;\n}"
                   }
              ]
          }
      ],
      "test_cases": [
          {
              "input": [[-1,0,1,2,-1,-4]],
              "output": [[-1,-1,2],[-1,0,1]],
              "description": "Two triplets found"
          },
          {
              "input": [[0,1,1]],
              "output": [],
              "description": "No such triplet"
          }
      ],
      "input_schema": [
          { "name": "nums", "type": "number[]", "label": "Numbers" }
      ],
      "metadata": {
           "companyTags": ["Amazon", "Facebook", "Microsoft", "Apple"],
          "likes": 28000,
          "dislikes": 2500
      }
  },
  {
      "id": "container-with-most-water",
      "title": "Container With Most Water",
      "name": "Container With Most Water",
      "category": "Two Pointers",
      "difficulty": "medium",
      "description": "Find two lines that together with the x-axis form a container, such that the container contains the most water.",
      "serial_no": 10,
      "list_type": "blind75",
      "explanation": {
          "problemStatement": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.",
          "steps": [
              "Init left pointer at 0, right at n-1.",
              "Calculate area: (right - left) * min(height[left], height[right]).",
              "Update maxArea.",
              "Move the pointer with smaller height inward.",
              "Repeat until left >= right."
          ],
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
      },
      "implementations": [
          {
              "lang": "typescript",
              "code": [
                   {
                      "codeType": "optimize",
                      "code": "function maxArea(height: number[]): number {\n    let l = 0;\n    let r = height.length - 1;\n    let res = 0;\n    while (l < r) {\n        const area = (r - l) * Math.min(height[l], height[r]);\n        res = Math.max(res, area);\n        if (height[l] < height[r]) {\n            l++;\n        } else {\n            r--;\n        }\n    }\n    return res;\n}"
                   }
              ]
          }
      ],
      "test_cases": [
          {
              "input": [[1,8,6,2,5,4,8,3,7]],
              "output": 49,
              "description": "Max area is 49"
          },
          {
              "input": [[1,1]],
              "output": 1,
              "description": "Max area is 1"
          }
      ],
      "input_schema": [
          { "name": "height", "type": "number[]", "label": "Heights" }
      ],
      "metadata": {
          "companyTags": ["Amazon", "Google", "Facebook"],
          "likes": 25000,
          "dislikes": 1300
      }
  }
]
